<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
<meta name="robots" content="index, follow">

    <title>Build Your Own Perplexity in 15 Minutes With Supermemory</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="preload" as="style" href="/blog/assets/built/screen.css?v=259661198b" />
    <link rel="preload" as="script" href="/blog/assets/built/casper.js?v=259661198b" />

    <link rel="stylesheet" type="text/css" href="/blog/assets/built/screen.css?v=259661198b" />

    <link rel="icon" href="https://supermemory.ai/blog/content/images/size/w256h256/2025/06/SuperM_LinkedIn-Github-Twitter_ProfilePicture--1--1.png" type="image/png">
    <link rel="canonical" href="https://supermemory.ai/blog/build-your-own-perplexity-in-15-minutes-with-supermemory/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="supermemory - Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Build Your Own Perplexity in 15 Minutes With Supermemory">
    <meta property="og:description" content="Supermemory has a fascinating open-source tool called OpenSearchAI. It&#x27;s essentially a search assistant similar to Perplexity, but it remembers everything you&#x27;ve searched for and enriches future responses with that memory.

I thought to myself, “This seems cool. But how complicated is it to build something like this?&quot;
So, I challenged">
    <meta property="og:url" content="https://supermemory.ai/blog/build-your-own-perplexity-in-15-minutes-with-supermemory/">
    <meta property="og:image" content="https://supermemory.ai/blog/content/images/2025/07/Frame_2147223302.webp">
    <meta property="article:published_time" content="2025-08-11T14:29:28.000Z">
    <meta property="article:modified_time" content="2025-08-12T04:17:21.000Z">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Build Your Own Perplexity in 15 Minutes With Supermemory">
    <meta name="twitter:description" content="Supermemory has a fascinating open-source tool called OpenSearchAI. It&#x27;s essentially a search assistant similar to Perplexity, but it remembers everything you&#x27;ve searched for and enriches future responses with that memory.

I thought to myself, “This seems cool. But how complicated is it to build something like this?&quot;
So, I challenged">
    <meta name="twitter:url" content="https://supermemory.ai/blog/build-your-own-perplexity-in-15-minutes-with-supermemory/">
    <meta name="twitter:image" content="https://supermemory.ai/blog/content/images/2025/07/Frame_2147223302.webp">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Naman Bansal">
    <meta name="twitter:site" content="@supermemoryai">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="676">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "supermemory - Blog",
        "url": "https://supermemory.ai/blog/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://supermemory.ai/blog/content/images/2025/06/Frame-2147223248.svg"
        }
    },
    "author": {
        "@type": "Person",
        "name": "Naman Bansal",
        "image": {
            "@type": "ImageObject",
            "url": "https://www.gravatar.com/avatar/1b424ffbaa308b371e62efa5919dfe3d?s=250&r=x&d=mp",
            "width": 250,
            "height": 250
        },
        "url": "https://supermemory.ai/blog/author/naman/",
        "sameAs": []
    },
    "headline": "Build Your Own Perplexity in 15 Minutes With Supermemory",
    "url": "https://supermemory.ai/blog/build-your-own-perplexity-in-15-minutes-with-supermemory/",
    "datePublished": "2025-08-11T14:29:28.000Z",
    "dateModified": "2025-08-12T04:17:21.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://supermemory.ai/blog/content/images/2025/07/Frame_2147223302.webp",
        "width": 1200,
        "height": 676
    },
    "description": "Supermemory has a fascinating open-source tool called OpenSearchAI. It&#x27;s essentially a search assistant similar to Perplexity, but it remembers everything you&#x27;ve searched for and enriches future responses with that memory.\n\nI thought to myself, “This seems cool. But how complicated is it to build something like this?&quot;\nSo, I challenged myself: Could I recreate a simplified version of this memory-enhanced Perplexity in just 30 mins?\n\nI did, and in this tutorial, I&#x27;m going to walk you through exact",
    "mainEntityOfPage": "https://supermemory.ai/blog/build-your-own-perplexity-in-15-minutes-with-supermemory/"
}
    </script>

    <meta name="generator" content="Ghost 5.130">
    <link rel="alternate" type="application/rss+xml" title="supermemory - Blog" href="https://supermemory.ai/blog/rss/">
    
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.8/umd/sodo-search.min.js" data-key="d2a094c14f6148bdbd8ad26051" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.8/umd/main.css" data-sodo-search="https://supermemory.ai/blog/" data-locale="en" crossorigin="anonymous"></script>
    
    <link href="https://supermemory.ai/blog/webmentions/receive/" rel="webmention">
    <script defer src="/blog/public/cards.min.js?v=259661198b"></script><style>:root {--ghost-accent-color: #3d49d8;}</style>
    <link rel="stylesheet" type="text/css" href="/blog/public/cards.min.css?v=259661198b">
    <style>
  .gh-footer-copyright {
    display: none !important;
}
a[href*="ghost.org"] {
    display: none !important;
}
::selection {
  background: #267BF1;
  color: #FFF;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Find all navigation logo links
    const logoLinks = document.querySelectorAll('.gh-navigation-logo');
    
    logoLinks.forEach(function(link) {
        // Change the href to point to main site
        link.href = 'https://supermemory.ai';
    });
});

  // Ensure all pages point to the main domain version
  const canonical = document.querySelector('link[rel="canonical"]');
  if (canonical && canonical.href.includes('blog.supermemory.ai')) {
    canonical.href = canonical.href.replace('blog.supermemory.ai', 'supermemory.ai/blog');
  }

if (typeof window !== 'undefined') {
  // Client-side check
  const hostname = window.location.hostname;
  const userAgent = navigator.userAgent;
  const isCloudflareWorker = userAgent.includes('Cloudflare-Workers');
  const isGhostAdmin = window.location.pathname.startsWith('/ghost');
  
  if (hostname === 'blog.supermemory.ai' && !isCloudflareWorker && !isGhostAdmin) {
    window.location.replace('https://supermemory.ai/blog' + window.location.pathname.replace('/blog', '') + window.location.search);
  }
}
</script>

<script>
    !function(t,e){var o,n,p,r;e.__SV||(window.posthog && window.posthog.__loaded)||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init Ce js Ls Te Fs Ds capture Ye calculateEventProperties zs register register_once register_for_session unregister unregister_for_session Ws getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Bs Us createPersonProfile Hs Ms Gs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Ns debug L qs getPageViewId captureTraceFeedback captureTraceMetric".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
    posthog.init('phc_9wkqAZtZYAUCNwvus0hYqcZbw5EBEX2s3QXjZoNdUNS', {
        api_host: 'https://us.i.posthog.com',
        defaults: '2025-05-24',
        person_profiles: 'identified_only', // or 'always' to create profiles for anonymous users as well
    })
</script>
    <link rel="preconnect" href="https://fonts.bunny.net"><link rel="stylesheet" href="https://fonts.bunny.net/css?family=space-grotesk:700|space-mono:400,700"><style>:root {--gh-font-heading: Space Grotesk;--gh-font-body: Space Mono;}</style>

</head>
<body class="post-template gh-font-heading-space-grotesk gh-font-body-space-mono is-head-left-logo">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://supermemory.ai/blog">
                        <img src="https://supermemory.ai/blog/content/images/2025/06/Frame-2147223248.svg" alt="supermemory - Blog">
                </a>
                <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger" aria-label="Main Menu"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://supermemory.ai">Home</a></li>
    <li class="nav-blogs"><a href="https://supermemory.ai/blog">Blogs</a></li>
    <li class="nav-updates"><a href="https://docs.supermemory.ai/changelog/overview">Updates</a></li>
    <li class="nav-docs"><a href="https://docs.supermemory.ai">Docs</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                        <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
            </div>
        </div>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
        </div>

        <h1 class="article-title">Build Your Own Perplexity in 15 Minutes With Supermemory</h1>


        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list instapaper_ignore">
                <li class="author-list-item">
                    <a href="/blog/author/naman/" class="author-avatar" aria-label="Read more of Naman Bansal">
                        <img class="author-profile-image" src="https://www.gravatar.com/avatar/1b424ffbaa308b371e62efa5919dfe3d?s&#x3D;250&amp;r&#x3D;x&amp;d&#x3D;mp" alt="Naman Bansal" />
                    </a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="/blog/author/naman/">Naman Bansal</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2025-08-11">11 Aug 2025</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 10 min read</span>
                </div>
            </div>

        </section>
        </div>

            <figure class="article-image">
                <img
                    srcset="/content/images/size/w300/2025/07/Frame_2147223302.webp 300w,
                            /content/images/size/w600/2025/07/Frame_2147223302.webp 600w,
                            /content/images/size/w1000/2025/07/Frame_2147223302.webp 1000w,
                            /content/images/size/w2000/2025/07/Frame_2147223302.webp 2000w"
                    sizes="(min-width: 1400px) 1400px, 92vw"
                    src="/blog/content/images/size/w2000/2025/07/Frame_2147223302.webp"
                    alt="Build Your Own Perplexity in 15 Minutes With Supermemory"
                />
            </figure>

    </header>

    <section class="gh-content gh-canvas">
        <p>Supermemory has a fascinating open-source tool called <a href="https://opensearch.supermemory.ai/?ref=blog.supermemory.ai" rel="noreferrer">OpenSearchAI</a>. It's essentially a search assistant similar to Perplexity, but it remembers everything you've searched for and enriches future responses with that memory.</p><p>I thought to myself, “This seems cool. But how complicated is it to build something like this?"<br>So, I challenged myself: Could I recreate a simplified version of this memory-enhanced Perplexity in just 30 mins?</p><p>I did, and in this tutorial, I'm going to walk you through exactly how you can do it too. We’ll build our very own mini-clone of OpenSearch using:</p><ul><li><strong>Supermemory's Memory API:</strong> A super-simple way to automatically save and retrieve memories without dealing with complicated vector databases or complex integrations.</li><li><strong>Brave Search API:</strong> A fast and easy API to pull relevant, real-time web results.</li><li><strong>OpenAI's GPT Model:</strong> Just one straightforward call to fuse memories and web search results into clean, easy-to-understand answers.</li></ul><p>Honestly, once I saw it working, I couldn’t believe how easy it had been to set up. Let’s dive right in.</p><p><a href="https://github.com/namancoderpro/mini-opensearch?ref=blog.supermemory.ai" rel="noreferrer">Here's the GitHub repo</a> with the full code for you to follow along.</p><h2 id="video">Video</h2><figure class="kg-card kg-embed-card"><iframe src="https://player.vimeo.com/video/1103047911?app_id=122963" width="426" height="240" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" referrerpolicy="strict-origin-when-cross-origin" title="perplexity-clone-video"></iframe></figure><h2 id="planning-a-rough-sketch">Planning: A Rough Sketch</h2><p>The actual coding is pretty straightforward for this kind of app, but getting clear on the overall idea and structure helps a ton.</p><p>Here's exactly how I thought through this:</p><h3 id="how-does-the-original-app-work">How does the original app work?</h3><p>Supermemory's OpenSearch AI does two main things really well:</p><ul><li>It searches the web and gives clear, concise answers.</li><li>It automatically remembers previous queries, using those memories to give better answers over time.</li></ul><p>So, in simple terms, we have two parts: web searching and memory. I wanted my app to do the same.</p><h3 id="picking-the-right-tools">Picking the Right Tools</h3><p>Here's my quick thought process on which tools to pick:</p><p><strong>Memory:</strong> This is the key feature, and luckily, Supermemory already gives me a simple, ready-to-use Memory API. No complicated databases or setup, just a clean, simple SDK to store and retrieve memories.</p><p><strong>Web Search:</strong> I needed a reliable search API to pull fresh web results. Brave Search is fast, simple, free, and developer-friendly.</p><p><strong>Answer Generation:</strong> To create those nice, readable responses combining memories and web results, a single call to OpenAI's API is perfect.</p><h3 id="quick-ui-sketch">Quick UI Sketch</h3><p>Here's the rough sketch I quickly drew up to clarify my thinking:</p><figure class="kg-card kg-image-card"><img src="https://i.postimg.cc/7YbxvtTb/Screenshot-2025-07-19-at-14-47-48.png" class="kg-image" alt="" loading="lazy" width="1274" height="800"></figure><p>In essence:</p><ul><li><strong>Frontend:</strong> Just a simple input for questions and a nice, clean way to show answers, memories, and web results.</li><li><strong>Backend:</strong> Takes user questions, interacts with memory, does a quick web search, and uses AI to generate answers.</li></ul><p>Here’s what the flowchart looks like:</p><figure class="kg-card kg-image-card"><img src="https://i.postimg.cc/WbQcBNvf/image.png" class="kg-image" alt="" loading="lazy" width="1068" height="800"></figure><p>That’s it! Let’s get into the actual coding now.</p><h2 id="building-this-app-step-by-step">Building this app: step-by-step</h2><h3 id="prerequisites">Prerequisites</h3><p>First, let’s create a folder and install <code>npm</code>. We’ll then install the dependencies.</p><pre><code class="language-bash">mkdir mini-opensearch
cd mini-opensearch
npm init -y
npm install express cors dotenv axios supermemory openai
</code></pre><p>Here’s what the dependencies are for:</p><ul><li><strong>express:</strong> Our backend API server.</li><li><strong>cors:</strong> Makes sure we don't run into annoying CORS issues.</li><li><strong>dotenv:</strong> Simple way to handle API keys and configs.</li><li><strong>axios:</strong> Easy HTTP requests.</li><li><strong>supermemory:</strong> Easy-to-use memory storage and retrieval.</li><li><strong>openai:</strong> For generating AI-powered responses.</li></ul><p>Create a <a>free supermemory account</a> and get the API key from your dashboard. Also, go to <a href="https://brave.com/search/api/?ref=blog.supermemory.ai">Brave Search API</a> and register for an account there. They have a free plan we’ll use for this tutorial, but you’ll have to enter your card details.</p><p>Finally, generate an OpenAI API Key using <a href="https://platform.openai.com/docs/quickstart?ref=blog.supermemory.ai">these steps.</a></p><p>Then, create a <code>.env</code> file in your folder and enter the following:</p><pre><code>SUPERMEMORY_API_KEY=...
OPENAI_API_KEY=...
BRAVE_SEARCH_API_KEY=...
</code></pre><h3 id="backend">Backend</h3><p>Awesome, now inside your folder, create a file <code>server.js</code> to set up the Express backend.</p><p>Import everything as follows:</p><pre><code class="language-js">// server.js
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import axios from 'axios';
import supermemory from 'supermemory';
import OpenAI from 'openai';
</code></pre><p>Configure the dotenv and start Express:</p><pre><code class="language-js">dotenv.config();
const app = express();

// ─── MIDDLEWARE──
// Enable CORS for all routes (you can lock this down to specific origins if you like)
app.use(cors());

// Parse JSON + serve frontend
app.use(express.json());
app.use(express.static('public'));
</code></pre><p>Create your Supermemory and OpenAI clients as follows:</p><pre><code class="language-js">const memoryClient = new supermemory({
 apiKey: process.env.SUPERMEMORY_API_KEY,
});
const openai = new OpenAI({
 apiKey: process.env.OPENAI_API_KEY,
});
</code></pre><p>Okay, now, according to our rough flowchart, we need to retrieve relevant memories, conduct web searches, and generate an LLM response.</p><p>Let’s start by tackling the web searches part using Brave’s Search API. We’ll create a function that will call the Brave API and get web search results for a query. Based on their documentation, write the following code:</p><pre><code class="language-js">async function braveSearch(query, count = 5) {
 const params = new URLSearchParams({
   q:           query,
   count:       count.toString(),
   country:     'US',
   search_lang: 'en',
   extra_snippets: 'true',
   text_decorations: 'false',
 });
 const url = `https://api.search.brave.com/res/v1/web/search?${params}`;

 const resp = await axios.get(url, {
   headers: {
     'Accept':               'application/json',
     'Accept-Encoding':      'gzip',
     'X-Subscription-Token': process.env.BRAVE_SEARCH_API_KEY,
   },
   timeout: 5000,
 });

 if (resp.status !== 200) {
   throw new Error(`Brave Search error ${resp.status}: ${resp.statusText}`);
 }
 const results = resp.data.web?.results;
 if (!Array.isArray(results)) {
   throw new Error(`Unexpected Brave response: ${JSON.stringify(resp.data)}`);
 }
 return results;
}
</code></pre><p>The function takes the <code>query</code> as an input parameter and the <code>count</code> variable specifies the number of results to extract. Then, we declare the search parameters using their <code>URLSearchParams</code> object and pass in the query and count.</p><p>The <code>extra_snippets</code> feature returns snippets from the webpage relating to our query, which can be useful while passing to the LLM and text_decorations has been set to false to prevent HTML from being given back.</p><p>Then, we append these params to the URL and send a GET request with the API Key in the <code>X-Subscription-Token</code> header. Pretty simple!</p><p>Now, let’s build the main endpoint of our app that will handle incoming user questions. Here's exactly what our endpoint will do:</p><ul><li>Receive a user question from the frontend.</li><li>Save the user's question into Supermemory for future context.</li><li>Retrieve the 3 most relevant past memories related to this question.</li><li>Fetch fresh web search results from Brave.</li><li>Combine memories and web results in a prompt for OpenAI.</li><li>Generate a crisp, concise answer with OpenAI.</li><li>Save this new AI-generated answer back into memory.</li><li>Send back the generated answer, relevant memories, and web results to the frontend.</li></ul><p>Start by creating an Express route:</p><pre><code class="language-js">app.post('/api/query', async (req, res) =&gt; {
  const { query } = req.body; // User's question
  if (!query || typeof query !== 'string') {
return res.status(400).json({ error: 'query must be a non-empty string' });
  }
});
</code></pre><p>Now, using Supermemory’s <code>add</code> function, add the memory to Supermemory:</p><pre><code class="language-js">await memoryClient.memories.add({ content: query });
</code></pre><p>This will help us remember each question and build better context for future queries. Next, retrieve the top 3 relevant queries from Supermemory:</p><pre><code class="language-js">// Retrieve memories with a limit of 3
const searchRes = await memoryClient.search.execute({ q: query, limit: 3 });

// Get the results from the response
const mems = searchRes.results;
</code></pre><p>Okay, now if you read Supermemory’s documentation, you’ll realize the response would look something like this:</p><pre><code>{
  "results": [
    {
      "documentId": "doc_xyz789",
      "chunks": [
        {
          "content": "Machine learning is a subset of artificial intelligence...",
          "isRelevant": true,
          "score": 0.85
        }
      ],
      "score": 0.95,
      "metadata": {
        "source": "web",
        "category": "technology"
      },
      "title": "Introduction to Machine Learning"
    }
  ],
  "total": 1,
  "timing": 123.45
}
</code></pre><p>I noticed a couple of things:</p><ul><li>Each memory has multiple "chunks" of text, and each chunk has a relevance score.</li><li>Some chunks aren't relevant (isRelevant: false), and we shouldn't include those.</li><li>I only wanted the single most relevant piece of text from each memory to keep things concise and focused for our AI.</li></ul><p>So, here’s the logic I went with:</p><ul><li><strong>Step 1:</strong> Loop over the top 3 memories Supermemory gave me (already sorted by overall memory score).</li><li><strong>Step 2:</strong> For each memory, find only the relevant chunks (isRelevant: true).</li><li><strong>Step 3:</strong> Pick the chunk with the highest score (since that's probably the most useful piece).</li><li><strong>Step 4:</strong> Create a simple bullet-point list where each bullet combines the memory's title and the best chunk's content.</li></ul><p>Here’s how the code looks:</p><pre><code class="language-js">   //Take the top 3 memories
   const top3 = mems.slice(0, 3);

   const memoryContext = top3.map(mem =&gt; {
  // Filter relevant chunks only
  const relevantChunks = mem.chunks.filter(c =&gt; c.isRelevant);

  // Pick the most relevant chunk (highest score)
  const bestChunk = relevantChunks.reduce((best, c) =&gt; c.score &gt; best.score ? c : best);

  // Format as "Title: content"
  return `- ${mem.title}: ${bestChunk.content}`;
}).join('\n');
</code></pre><p>Great! Now, let’s add a line to do the web search:</p><pre><code class="language-js">const webResults = await braveSearch(query, 5);
</code></pre><p>Our results from Brave include a <code>description</code> of the page and a list of <code>extraSnippets</code>. We’ll enrich the results with both to make sure our LLM gets as much context as possible. Write the following code:</p><pre><code class="language-js">const enrichedResults = webResults.map((r, i) =&gt; {

  // Collect all available snippets: description + any extras
  const allSnips = [r.description, ...(r.extraSnippets || [])];

  // Choose the longest one (assuming more detail = more context)
  const bestSnippet = allSnips.reduce((a, b) =&gt;
    a.length &gt; b.length ? a : b
  , allSnips[0]);

  return {
    title:   r.title,
    url:     r.url,
    snippet: bestSnippet.trim()
  };

});

const webSummaries = enrichedResults
   .map((r, i) =&gt; `${i+1}. ${r.snippet} — ${r.url}`)
   .join('\n\n');
</code></pre><p>This code collects all the snippets we got back in an array and then chooses the longest snippet for each webpage, assuming the longer one would give us more context.</p><p>And then, it returns an object with the title, URL, and the best snippet. Finally, we format them in a clean list.</p><p>Awesome! Now, we just need to pass all the information we’ve gathered into our LLM. In the <code>server.js</code> file, create the prompts:</p><pre><code class="language-js">const systemPrompt = `
You are a helpful assistant.
Use the user’s past memories plus these fresh web results to craft a concise answer.
Then list the most relevant URLs at the end.
   `.trim();

const userPrompt = `
Query: ${query}

Memories:
${memoryContext}

Web Results:
${webSummaries}

Please answer and then list the top links.
   `.trim();
</code></pre><p>The <code>systemPrompt</code> contains the instructions, while the <code>userPrompt</code> contains the query and the context. Finally, we call OpenAI with these prompts:</p><pre><code class="language-js">const chat = await openai.chat.completions.create({
     model:       'gpt-4o-mini',
     messages:    [
       { role: 'system', content: systemPrompt },
       { role: 'user',   content: userPrompt   },
     ],
     temperature: 0.2,
   });

const answer = chat.choices[0].message.content;
</code></pre><p>And, the last step is saving the answer to memory and returning everything.</p><pre><code class="language-js"> // 6) Save AI answer
await memoryClient.memories.add({ content: answer });

// 7) Return everything
res.json({ answer, memories: mems, searchResults: webResults });
</code></pre><p>Now, start the server on port 3000:</p><pre><code class="language-js">const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; console.log(`Listening on http://localhost:${PORT}`));
</code></pre><p>Voila! The backend is done. This took 20 mins tops. Now, onto the frontend.</p><h3 id="frontend">Frontend</h3><p>I’m keeping things simple here. So, I won’t be using any React or Tailwind. Just plain old HTML, CSS, and JS.</p><p>Our goal is to let the user enter a query, send it to the backend, and show the answer, web results, and relevant past memories.</p><p>Inside your project folder, create a <code>public</code> folder and an <code>index.html</code> file inside it.</p><p>Here’s the basic HTML skeleton:</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;Mini OpenSearch AI&lt;/title&gt;

  &lt;!-- For rendering Markdown responses and sanitizing --&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/<a href="/blog/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="54303b392421263d322d14667a607a64">[email&#160;protected]</a>/dist/purify.min.js"&gt;&lt;/script&gt;

  &lt;style&gt;
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 2rem auto;
      line-height: 1.6;
    }
    input {
      width: 70%;
      padding: 0.6rem;
      font-size: 1rem;
    }
    button {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      margin-left: 0.5rem;
      cursor: pointer;
    }
    h2 { margin-top: 2rem; }
    #answer { background: #f6f8fa; padding: 1rem; white-space: pre-wrap; }
    ul { list-style: none; padding: 0; }
    li { margin-bottom: 1rem; }
    a { color: #0366d6; text-decoration: none; font-weight: bold; }
    a:hover { text-decoration: underline; }
    .snippet { color: #444; margin-top: 0.25rem; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Mini OpenSearch AI&lt;/h1&gt;

  &lt;div&gt;
    &lt;input id="query" placeholder="Ask something…" /&gt;
    &lt;button id="search"&gt;Search&lt;/button&gt;
  &lt;/div&gt;

  &lt;h2&gt;Answer&lt;/h2&gt;
  &lt;div id="answer"&gt;Your AI-enhanced answer will appear here.&lt;/div&gt;

  &lt;h2&gt;Web Results&lt;/h2&gt;
  &lt;ul id="results"&gt;&lt;/ul&gt;

  &lt;h2&gt;Relevant Memories&lt;/h2&gt;
  &lt;ul id="memories"&gt;&lt;/ul&gt;
</code></pre><p>This has some basic styling and just four sections: ask something, AI-enhanced answer, web results, and relevant memories.</p><p>Here’s what it looks like:</p><figure class="kg-card kg-image-card"><img src="https://i.postimg.cc/fbpt0mWz/Screenshot-2025-07-19-at-14-54-21.png" class="kg-image" alt="" loading="lazy" width="1280" height="545"></figure><p>Now, let’s add the logic when the user presses ‘Search’. Here’s how:</p><pre><code>&lt;script&gt;
   const queryInput = document.getElementById('query');
   const searchButton = document.getElementById('search');
   const answerDiv = document.getElementById('answer');
   const resultsList = document.getElementById('results');
   const memoriesList = document.getElementById('memories');

   searchButton.addEventListener('click', async () =&gt; {
     const query = queryInput.value.trim();
     if (!query) return alert('Please enter a query.');

     // Show loading state
     answerDiv.textContent = 'Loading…';
     resultsList.innerHTML = '';
     memoriesList.innerHTML = '';

     try {
       const res = await fetch('/api/query', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ query })
       });
       if (!res.ok) throw new Error(`Server error: ${res.statusText}`);
       const { answer, searchResults, memories } = await res.json();

       const rawHtml = marked.parse(answer);
       answerDiv.innerHTML = DOMPurify.sanitize(rawHtml)

       // Render Brave search results
       for (const r of searchResults) {
         const li = document.createElement('li');
         const link = document.createElement('a');
         link.href = r.url;
         link.target = '_blank';
         link.rel = 'noopener';
         link.textContent = r.title;
         li.appendChild(link);

         const snippet = document.createElement('div');
         snippet.className = 'snippet';
         snippet.textContent = r.description;
         li.appendChild(snippet);

         resultsList.appendChild(li);
       }

        const top3 = (memories || [])
         .sort((a, b) =&gt; b.score - a.score)
         .slice(0, 3);

       for (const mem of top3) {
         // find the most relevant chunk
         const chunk = Array.isArray(mem.chunks)
           ? mem.chunks.reduce((best, c) =&gt; c.score &gt; best.score ? c : best, mem.chunks[0])
           : { content: '' };

         const li = document.createElement('li');
         li.className = 'mem-item';
         // show title and chunk content
         li.innerHTML = `&lt;strong&gt;${mem.title}&lt;/strong&gt;&lt;br&gt;${chunk.content}`;
         memoriesList.appendChild(li);
       }
     } catch (err) {
       console.error(err);
       answerDiv.textContent = 'Error: ' + err.message;
     }
   });
&lt;/script&gt;
</code></pre><p>Most of the above logic is simple. We add an <code>eventListener</code> called ‘click’ to the search button. That means, whenever the button is clicked, we run the given function.</p><p>Meanwhile, the function extracts the user’s query from the input box, sends a POST request to our API endpoint, and waits for the response. Then, it converts the Markdown response to normal text and renders the Brave result and the relevant memories.</p><p>And, that’s it! You’ve built your very own Perplexity/Supermemory OpenSearch clone. It wasn’t that hard, right?</p><p>Now, you can fire away and test this! Start the server using:</p><pre><code>node server.js
</code></pre><p>And then open your browser and go to <a href="http://localhost:3000/?ref=blog.supermemory.ai">http://localhost:3000</a></p><h2 id="conclusion">Conclusion</h2><p>And that’s a wrap. You now have your own mini clone of OpenSearch AI. The whole point of this wasn’t to build something massive or production-ready. It was to show how surprisingly little it takes to wire something like this up when you’ve got the right tools.</p><p>Once you have memory as a primitive, you start thinking differently about what apps can do. You stop worrying about sessions and state and all that, because the app can just remember.</p><p>If you’re curious, <a>go try Supermemory</a>. Sign up, play around, plug it into whatever you’re working on. You’ll be surprised how far you can get with a single .add() and .search().</p><p>Hope this helped. Go build something fun.</p>
    </section>


</article>
</main>




            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post keep-ratio">

    <a class="post-card-image-link" href="/blog/matryoshka-representation-learning-the-ultimate-guide-how-we-use-it/">

        <img class="post-card-image"
            srcset="/content/images/size/w300/2025/10/Matryoshka-Representation-Learning.png 300w,
                    /content/images/size/w600/2025/10/Matryoshka-Representation-Learning.png 600w,
                    /content/images/size/w1000/2025/10/Matryoshka-Representation-Learning.png 1000w,
                    /content/images/size/w2000/2025/10/Matryoshka-Representation-Learning.png 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/blog/content/images/size/w600/2025/10/Matryoshka-Representation-Learning.png"
            alt="Matryoshka Representation Learning: The Ultimate Guide &amp; How We Use It"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/matryoshka-representation-learning-the-ultimate-guide-how-we-use-it/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Matryoshka Representation Learning: The Ultimate Guide &amp; How We Use It
                </h2>
            </header>
                <div class="post-card-excerpt">Embeddings are the cornerstone of any retrieval system. And the larger the embeddings, the more information they can store.

But large embeddings require a lot of memory, which leads to high computational costs and latency.

To reduce this high cost, we can use models that produce embeddings with small dimensions,</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2025-10-19">19 Oct 2025</time>
                <span class="post-card-meta-length">8 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post keep-ratio">

    <a class="post-card-image-link" href="/blog/incident-report-october-18-2025-service-degradation/">

        <img class="post-card-image"
            srcset="/content/images/size/w300/2025/10/Frame-2147228224.png 300w,
                    /content/images/size/w600/2025/10/Frame-2147228224.png 600w,
                    /content/images/size/w1000/2025/10/Frame-2147228224.png 1000w,
                    /content/images/size/w2000/2025/10/Frame-2147228224.png 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/blog/content/images/size/w600/2025/10/Frame-2147228224.png"
            alt="Incident Report: October 18, 2025 Service Degradation"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/incident-report-october-18-2025-service-degradation/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Incident Report: October 18, 2025 Service Degradation
                </h2>
            </header>
                <div class="post-card-excerpt">Summary

On October 18, between 1:17 PM and 1:45 PM PDT, we experienced service degradation that resulted in elevated API response times and some timeouts. This happened when two enterprise customers started major data backfills simultaneously— while we&#39;d planned for one, the second caught us by</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2025-10-19">19 Oct 2025</time>
                <span class="post-card-meta-length">6 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post keep-ratio">

    <a class="post-card-image-link" href="/blog/how-to-make-your-mcp-clients-share-context-with-supermemory-mcp/">

        <img class="post-card-image"
            srcset="/content/images/size/w300/2025/10/18.png 300w,
                    /content/images/size/w600/2025/10/18.png 600w,
                    /content/images/size/w1000/2025/10/18.png 1000w,
                    /content/images/size/w2000/2025/10/18.png 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/blog/content/images/size/w600/2025/10/18.png"
            alt="How To Make Your MCP Clients Share Context with Supermemory MCP"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/how-to-make-your-mcp-clients-share-context-with-supermemory-mcp/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    How To Make Your MCP Clients Share Context with Supermemory MCP
                </h2>
            </header>
                <div class="post-card-excerpt">Let’s get practical here: have you ever dropped a PDF into Cursor, then pasted the same content into Claude just to “remind it”? Or tried to follow up on a thread, only to realize the memory lives in a different tool?

It’s annoying. It breaks your flow. And</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2025-10-07">07 Oct 2025</time>
                <span class="post-card-meta-length">5 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://supermemory.ai/blog">supermemory - Blog</a> &copy; 2025</section>
            <nav class="site-footer-nav">
                <ul class="nav">
    <li class="nav-sign-up"><a href="#/portal/">Sign up</a></li>
    <li class="nav-get-started"><a href="https://console.supermemory.ai">Get Started</a></li>
</ul>

            </nav>
            <div class="gh-powered-by"><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script data-cfasync="false" src="/blog/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="/blog/assets/built/casper.js?v=259661198b"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<script>
  // Change main logo link
  const mainLogo = document.querySelector('a.gh-head-logo');
  if (mainLogo) {
    mainLogo.href = "https://supermemory.ai/";
  }

  // Add "Get Started" button to gh-head-actions
  const actionsDiv = document.querySelector('div.gh-head-actions');
  if (actionsDiv) {
    const btn = document.createElement('a');
    btn.href = "https://console.supermemory.ai";
    btn.textContent = "Get Started";

    // Button styles
    btn.style.background = "#267BF1";
    btn.style.color = "#FFF";
    btn.style.padding = "1rem 2rem";
    btn.style.borderRadius = "6px";
    btn.style.fontWeight = "600";
    btn.style.textDecoration = "none";
    btn.style.fontSize = "1.6rem";
    btn.style.transition = "background 0.2s";
    btn.onmouseover = () => btn.style.background = "#1563c7";
    btn.onmouseout = () => btn.style.background = "#267BF1";

    actionsDiv.appendChild(btn);
  }
</script>

</body>
</html>
