import type { TRPCRouterRecord } from "@trpc/server";
import { TRPCError } from "@trpc/server";
import { db } from "@db/console/client";
import { orgApiKeys, orgWorkspaces } from "@db/console/schema";
import { eq, and, desc } from "drizzle-orm";
import {
  createOrgApiKeySchema,
  revokeOrgApiKeySchema,
  deleteOrgApiKeySchema,
  rotateOrgApiKeySchema,
  listOrgApiKeysSchema,
} from "@repo/console-validation/schemas";
import { LIGHTFAST_API_KEY_PREFIX } from "@repo/console-api-key";
import { unkey, UNKEY_API_ID } from "@vendor/unkey";
import { recordCriticalActivity } from "../../lib/activity";

import { orgScopedProcedure } from "../../trpc";

/**
 * Organization API Keys Router
 *
 * Manages organization-scoped API keys for secure, isolated API access.
 * Each key is bound to a specific workspace. Key creation and verification
 * is handled by Unkey — the DB table stores metadata only.
 *
 * Security:
 * - Keys are generated by Unkey with sk_lf_ prefix
 * - Full key is only returned once on creation (never again)
 * - Keys can be revoked (soft delete via Unkey + DB) or permanently deleted
 * - Key rotation revokes old key in Unkey and creates a new one
 * - Rate limiting: 1000 req/min per key enforced by Unkey
 * - All operations are tracked via recordCriticalActivity (Tier 1)
 */
export const orgApiKeysRouter = {
  /**
   * List all API keys for a workspace
   * Returns keys with preview only (never full key)
   */
  list: orgScopedProcedure
    .input(listOrgApiKeysSchema)
    .query(async ({ ctx, input }) => {
      // Verify workspace belongs to org
      const workspace = await db.query.orgWorkspaces.findFirst({
        where: and(
          eq(orgWorkspaces.id, input.workspaceId),
          eq(orgWorkspaces.clerkOrgId, ctx.auth.orgId)
        ),
        columns: { id: true },
      });

      if (!workspace) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Workspace not found",
        });
      }

      const keys = await db.query.orgApiKeys.findMany({
        where: eq(orgApiKeys.workspaceId, input.workspaceId),
        columns: {
          publicId: true,
          name: true,
          keyPrefix: true,
          keySuffix: true,
          isActive: true,
          expiresAt: true,
          lastUsedAt: true,
          createdAt: true,
          createdByUserId: true,
        },
        orderBy: [desc(orgApiKeys.createdAt)],
      });

      return keys.map((key) => ({
        id: key.publicId,
        name: key.name,
        keyPreview: `${key.keyPrefix}...${key.keySuffix}`,
        isActive: key.isActive,
        expiresAt: key.expiresAt,
        lastUsedAt: key.lastUsedAt,
        createdAt: key.createdAt,
        createdByUserId: key.createdByUserId,
      }));
    }),

  /**
   * Create a new organization API key via Unkey
   * Returns the full key ONLY on creation (never again)
   */
  create: orgScopedProcedure
    .input(createOrgApiKeySchema)
    .mutation(async ({ ctx, input }) => {
      // Verify workspace belongs to org
      const workspace = await db.query.orgWorkspaces.findFirst({
        where: and(
          eq(orgWorkspaces.id, input.workspaceId),
          eq(orgWorkspaces.clerkOrgId, ctx.auth.orgId)
        ),
        columns: { id: true, clerkOrgId: true },
      });

      if (!workspace) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Workspace not found",
        });
      }

      // Create key via Unkey
      const unkeyResponse = await unkey.keys.createKey({
        apiId: UNKEY_API_ID,
        prefix: "sk_lf",
        name: input.name,
        externalId: workspace.id, // workspaceId for reference
        meta: {
          workspaceId: workspace.id,
          clerkOrgId: workspace.clerkOrgId,
          createdBy: ctx.auth.userId,
        },
        expires: input.expiresAt ? input.expiresAt.getTime() : undefined,
        ratelimits: [
          {
            name: "default",
            limit: 1000,
            duration: 60000, // 1000 req/min
          },
        ],
      });

      const unkeyData = unkeyResponse.data;

      if (!unkeyData.keyId || !unkeyData.key) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create API key",
        });
      }

      // Determine suffix: last 4 chars of the key after the prefix
      // Unkey keys look like: sk_lf_<random> — take last 4 chars of the full key
      const keySuffix = unkeyData.key.slice(-4);

      const [created] = await db
        .insert(orgApiKeys)
        .values({
          workspaceId: input.workspaceId,
          clerkOrgId: workspace.clerkOrgId,
          createdByUserId: ctx.auth.userId,
          name: input.name,
          keyHash: null, // Unkey manages verification — no local hash needed
          keyPrefix: LIGHTFAST_API_KEY_PREFIX,
          keySuffix,
          unkeyKeyId: unkeyData.keyId,
          expiresAt: input.expiresAt?.toISOString(),
        })
        .returning({
          id: orgApiKeys.id,
          publicId: orgApiKeys.publicId,
        });

      if (!created) {
        // Rollback: disable the Unkey key we just created
        await unkey.keys.updateKey({ keyId: unkeyData.keyId, enabled: false }).catch((e: unknown) => {
          console.error("Rollback (disable Unkey key) failed:", e instanceof Error ? e.message : String(e));
        });
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create API key",
        });
      }

      // Track API key creation (security-critical)
      await recordCriticalActivity({
        workspaceId: input.workspaceId,
        actorType: "user",
        actorUserId: ctx.auth.userId,
        category: "api_key",
        action: "apikey.created",
        entityType: "org_api_key",
        entityId: created.publicId,
        metadata: {
          keyId: created.publicId,
          keyName: input.name,
          keyPreview: `${LIGHTFAST_API_KEY_PREFIX}...${keySuffix}`,
          expiresAt: input.expiresAt?.toISOString() ?? null,
        },
      });

      // Return the full key ONLY on creation (never again)
      return {
        id: created.publicId,
        key: unkeyData.key, // Full key - only returned once!
        name: input.name,
        keyPreview: `${LIGHTFAST_API_KEY_PREFIX}...${keySuffix}`,
        expiresAt: input.expiresAt?.toISOString() ?? null,
        createdAt: new Date().toISOString(),
      };
    }),

  /**
   * Revoke (soft delete) an API key
   * Key remains in DB but is disabled in Unkey
   */
  revoke: orgScopedProcedure
    .input(revokeOrgApiKeySchema)
    .mutation(async ({ ctx, input }) => {
      // Find key
      const existingKey = await db.query.orgApiKeys.findFirst({
        where: eq(orgApiKeys.publicId, input.keyId),
        columns: {
          id: true,
          publicId: true,
          workspaceId: true,
          name: true,
          keyPrefix: true,
          keySuffix: true,
          isActive: true,
          unkeyKeyId: true,
        },
      });

      if (!existingKey) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "API key not found",
        });
      }

      // Verify workspace belongs to org
      const workspace = await db.query.orgWorkspaces.findFirst({
        where: and(
          eq(orgWorkspaces.id, existingKey.workspaceId),
          eq(orgWorkspaces.clerkOrgId, ctx.auth.orgId)
        ),
        columns: { id: true },
      });

      if (!workspace) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Access denied",
        });
      }

      if (!existingKey.isActive) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "API key is already revoked",
        });
      }

      // Revoke in Unkey first — halt if it fails to prevent inconsistent state
      if (existingKey.unkeyKeyId) {
        try {
          await unkey.keys.updateKey({ keyId: existingKey.unkeyKeyId, enabled: false });
        } catch (e) {
          console.error("Unkey revoke failed:", e instanceof Error ? e.message : String(e));
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to revoke API key",
          });
        }
      }

      try {
        await db
          .update(orgApiKeys)
          .set({ isActive: false, updatedAt: new Date().toISOString() })
          .where(eq(orgApiKeys.id, existingKey.id));
      } catch {
        // DB failed after Unkey revoke succeeded — re-enable Unkey key to stay consistent
        if (existingKey.unkeyKeyId) {
          await unkey.keys
            .updateKey({ keyId: existingKey.unkeyKeyId, enabled: true })
            .catch((rollbackErr: unknown) => {
              console.error("Unkey rollback (re-enable) failed:", rollbackErr instanceof Error ? rollbackErr.message : String(rollbackErr));
            });
        }
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to update API key record",
        });
      }

      // Track API key revocation (security-critical)
      await recordCriticalActivity({
        workspaceId: existingKey.workspaceId,
        actorType: "user",
        actorUserId: ctx.auth.userId,
        category: "api_key",
        action: "apikey.revoked",
        entityType: "org_api_key",
        entityId: existingKey.publicId,
        metadata: {
          keyId: existingKey.publicId,
          keyName: existingKey.name,
          keyPreview: `${existingKey.keyPrefix}...${existingKey.keySuffix}`,
        },
      });

      return { success: true };
    }),

  /**
   * Permanently delete an API key
   * Key is removed from Unkey and from the database
   */
  delete: orgScopedProcedure
    .input(deleteOrgApiKeySchema)
    .mutation(async ({ ctx, input }) => {
      // Find key
      const existingKey = await db.query.orgApiKeys.findFirst({
        where: eq(orgApiKeys.publicId, input.keyId),
        columns: {
          id: true,
          publicId: true,
          workspaceId: true,
          name: true,
          keyPrefix: true,
          keySuffix: true,
          createdAt: true,
          unkeyKeyId: true,
        },
      });

      if (!existingKey) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "API key not found",
        });
      }

      // Verify workspace belongs to org
      const workspace = await db.query.orgWorkspaces.findFirst({
        where: and(
          eq(orgWorkspaces.id, existingKey.workspaceId),
          eq(orgWorkspaces.clerkOrgId, ctx.auth.orgId)
        ),
        columns: { id: true },
      });

      if (!workspace) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Access denied",
        });
      }

      // Delete from Unkey first — halt if it fails to prevent orphaned DB rows
      if (existingKey.unkeyKeyId) {
        try {
          await unkey.keys.deleteKey({ keyId: existingKey.unkeyKeyId });
        } catch (e) {
          console.error("Unkey delete failed:", e instanceof Error ? e.message : String(e));
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to delete API key from auth provider",
          });
        }
      }

      await db
        .delete(orgApiKeys)
        .where(eq(orgApiKeys.id, existingKey.id));

      // Track API key deletion (security-critical)
      await recordCriticalActivity({
        workspaceId: existingKey.workspaceId,
        actorType: "user",
        actorUserId: ctx.auth.userId,
        category: "api_key",
        action: "apikey.deleted",
        entityType: "org_api_key",
        entityId: existingKey.publicId,
        metadata: {
          keyId: existingKey.publicId,
          keyName: existingKey.name,
          keyPreview: `${existingKey.keyPrefix}...${existingKey.keySuffix}`,
          originallyCreatedAt: existingKey.createdAt,
        },
      });

      return { success: true };
    }),

  /**
   * Rotate an API key (revoke old in Unkey, create new with same name)
   * Returns the new full key ONLY on rotation (never again)
   */
  rotate: orgScopedProcedure
    .input(rotateOrgApiKeySchema)
    .mutation(async ({ ctx, input }) => {
      // Find existing key
      const existingKey = await db.query.orgApiKeys.findFirst({
        where: eq(orgApiKeys.publicId, input.keyId),
        columns: {
          id: true,
          publicId: true,
          workspaceId: true,
          clerkOrgId: true,
          name: true,
          keyPrefix: true,
          keySuffix: true,
          isActive: true,
          unkeyKeyId: true,
        },
      });

      if (!existingKey) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "API key not found",
        });
      }

      // Verify workspace belongs to org
      const workspace = await db.query.orgWorkspaces.findFirst({
        where: and(
          eq(orgWorkspaces.id, existingKey.workspaceId),
          eq(orgWorkspaces.clerkOrgId, ctx.auth.orgId)
        ),
        columns: { id: true },
      });

      if (!workspace) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Access denied",
        });
      }

      // 1. Create new key in Unkey FIRST — prevents leaving user with no working key if creation fails
      const unkeyResponse = await unkey.keys.createKey({
        apiId: UNKEY_API_ID,
        prefix: "sk_lf",
        name: existingKey.name,
        externalId: existingKey.workspaceId,
        meta: {
          workspaceId: existingKey.workspaceId,
          clerkOrgId: existingKey.clerkOrgId,
          createdBy: ctx.auth.userId,
        },
        expires: input.expiresAt ? input.expiresAt.getTime() : undefined,
        ratelimits: [
          {
            name: "default",
            limit: 1000,
            duration: 60000,
          },
        ],
      });

      const newUnkeyData = unkeyResponse.data;

      if (!newUnkeyData.keyId || !newUnkeyData.key) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create replacement API key",
        });
      }

      const newKeySuffix = newUnkeyData.key.slice(-4);

      // 2. Disable old key in Unkey — fail and rollback if this doesn't succeed
      //    to prevent both old and new keys being active simultaneously
      if (existingKey.unkeyKeyId) {
        try {
          await unkey.keys.updateKey({ keyId: existingKey.unkeyKeyId, enabled: false });
        } catch {
          // Rollback: disable the newly created key so we don't leave two active keys
          await unkey.keys
            .updateKey({ keyId: newUnkeyData.keyId, enabled: false })
            .catch((rollbackErr: unknown) => {
              console.error("Rollback (disable new key) failed:", rollbackErr instanceof Error ? rollbackErr.message : String(rollbackErr));
            });
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to disable old API key during rotation",
          });
        }
      }

      // 3. DB transaction: deactivate old, insert new
      const [newKey] = await db.transaction(async (tx) => {
        await tx
          .update(orgApiKeys)
          .set({ isActive: false, updatedAt: new Date().toISOString() })
          .where(eq(orgApiKeys.id, existingKey.id));

        return tx
          .insert(orgApiKeys)
          .values({
            workspaceId: existingKey.workspaceId,
            clerkOrgId: existingKey.clerkOrgId,
            createdByUserId: ctx.auth.userId,
            name: existingKey.name,
            keyHash: null,
            keyPrefix: LIGHTFAST_API_KEY_PREFIX,
            keySuffix: newKeySuffix,
            unkeyKeyId: newUnkeyData.keyId,
            expiresAt: input.expiresAt?.toISOString(),
          })
          .returning({
            id: orgApiKeys.id,
            publicId: orgApiKeys.publicId,
          });
      });

      if (!newKey) {
        // Rollback: disable new Unkey key and attempt to re-enable old key
        await unkey.keys
          .updateKey({ keyId: newUnkeyData.keyId, enabled: false })
          .catch((e: unknown) => {
            console.error("Rollback (disable new key) failed:", e instanceof Error ? e.message : String(e));
          });
        if (existingKey.unkeyKeyId) {
          await unkey.keys
            .updateKey({ keyId: existingKey.unkeyKeyId, enabled: true })
            .catch((e: unknown) => {
              console.error("Rollback (re-enable old key) failed:", e instanceof Error ? e.message : String(e));
            });
        }
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to rotate API key",
        });
      }

      // Track API key rotation (security-critical)
      await recordCriticalActivity({
        workspaceId: existingKey.workspaceId,
        actorType: "user",
        actorUserId: ctx.auth.userId,
        category: "api_key",
        action: "apikey.rotated",
        entityType: "org_api_key",
        entityId: newKey.publicId,
        metadata: {
          oldKeyId: existingKey.publicId,
          newKeyId: newKey.publicId,
          keyName: existingKey.name,
          newKeyPreview: `${LIGHTFAST_API_KEY_PREFIX}...${newKeySuffix}`,
        },
        relatedActivityId: existingKey.publicId,
      });

      return {
        id: newKey.publicId,
        key: newUnkeyData.key, // Full key - only returned once!
        name: existingKey.name,
        keyPreview: `${LIGHTFAST_API_KEY_PREFIX}...${newKeySuffix}`,
        expiresAt: input.expiresAt?.toISOString() ?? null,
        createdAt: new Date().toISOString(),
      };
    }),
} satisfies TRPCRouterRecord;
