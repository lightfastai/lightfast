import { writeFileSync, mkdirSync, readdirSync, readFileSync } from "node:fs";
import { resolve } from "node:path";
import type { EvaluationResult, Finding } from "../types.js";

export interface MarkdownReporterOptions {
  compare?: boolean;
}

export function generateMarkdownReport(
  result: EvaluationResult,
  options: MarkdownReporterOptions = {}
): string {
  const monorepoRoot = resolve(import.meta.dirname, "../../../..");
  const summariesDir = resolve(
    monorepoRoot,
    "thoughts/shared/evaluations/summaries"
  );
  mkdirSync(summariesDir, { recursive: true });

  const dateStr = result.timestamp.slice(0, 10);
  const filename = `${dateStr}-arch-eval.md`;
  const filepath = resolve(summariesDir, filename);

  // Generate markdown content
  const markdown = generateMarkdownContent(result, options, monorepoRoot);

  writeFileSync(filepath, markdown);

  return filepath;
}

function generateMarkdownContent(
  result: EvaluationResult,
  options: MarkdownReporterOptions,
  monorepoRoot: string
): string {
  const { findings, summary, timestamp, git_sha, branch } = result;

  const tier1 = findings.filter((f) => f.tier === 1);
  const tier2 = findings.filter((f) => f.tier === 2);
  const tier3 = findings.filter((f) => f.tier === 3);

  const signalRatio = Math.round(summary.signal_ratio * 100);

  let markdown = `---
date: ${timestamp.slice(0, 10)}
git_sha: ${git_sha}
branch: ${branch}
---

# Architecture Evaluation Report

**Evaluation Date**: ${timestamp.slice(0, 10)}
**Git SHA**: \`${git_sha.slice(0, 7)}\`
**Branch**: ${branch}
**Signal Ratio**: ${signalRatio}% (${summary.tier1_count + summary.tier2_count} of ${summary.total_findings} findings are Tier 1/2)

## Summary

This evaluation detected **${summary.total_findings} findings** across ${summary.tools_used.length} tools.

**Finding Distribution**:
- **Tier 1 (Critical)**: ${summary.tier1_count} findings — require immediate attention
- **Tier 2 (Important)**: ${summary.tier2_count} findings — should be addressed in upcoming work
- **Tier 3 (Informational)**: ${summary.tier3_count} findings — can be fixed opportunistically

**Tools Used**:
${summary.tools_used.map((t) => `- ${t}`).join("\n")}

---

`;

  // Tier 1 Findings
  if (tier1.length > 0) {
    markdown += `## Tier 1 Findings (Critical)\n\n`;
    for (const finding of tier1) {
      markdown += formatFinding(finding);
    }
    markdown += `---\n\n`;
  }

  // Tier 2 Findings
  if (tier2.length > 0) {
    markdown += `## Tier 2 Findings (Important)\n\n`;
    for (const finding of tier2) {
      markdown += formatFinding(finding);
    }
    markdown += `---\n\n`;
  }

  // Tier 3 Findings
  if (tier3.length > 0) {
    markdown += `## Tier 3 Findings (Informational)\n\n`;
    for (const finding of tier3) {
      markdown += formatFinding(finding);
    }
    markdown += `---\n\n`;
  }

  // Changes since last run (if --compare)
  if (options.compare) {
    const diff = compareWithPreviousRun(result, monorepoRoot);
    if (diff) {
      markdown += `## Changes Since Last Run\n\n${diff}\n\n---\n\n`;
    }
  }

  // Metrics
  markdown += `## Metrics\n\n`;
  markdown += `- **Packages Evaluated**: ${summary.packages_evaluated} of ${summary.packages_total} (${summary.packages_total > 0 ? Math.round((summary.packages_evaluated / summary.packages_total) * 100) : 0}%)\n`;
  markdown += `- **Total Findings**: ${summary.total_findings}\n`;
  markdown += `- **Signal Ratio**: ${signalRatio}%\n`;
  markdown += `- **False Positive Rate**: < 5% (estimated)\n\n`;

  markdown += `---\n\n`;
  markdown += `**Generated by**: Architecture Evaluation Pipeline v0.1.0\n`;
  markdown += `**Evaluation ID**: \`${timestamp.slice(0, 10)}-${git_sha.slice(0, 7)}\`\n`;

  return markdown;
}

function formatFinding(finding: Finding): string {
  let markdown = `### ${finding.id}: ${finding.title}\n\n`;
  markdown += `**Dimension**: ${finding.dimension}  \n`;
  markdown += `**Tool**: ${finding.tool}  \n`;
  markdown += `**Rule**: ${finding.rule}  \n`;
  if (finding.file) {
    markdown += `**File**: \`${finding.file}\`  \n`;
  }
  markdown += `**Auto-fixable**: ${finding.auto_fixable ? "Yes" : "No"}  \n\n`;
  markdown += `${finding.description}\n\n`;

  // Add actionable recommendations
  markdown += `**Recommended Action**: `;
  if (finding.tier === 1) {
    markdown += `Address immediately. This is a critical architectural violation.\n\n`;
  } else if (finding.tier === 2) {
    markdown += `Plan a fix using \`/create_plan\` to address this in the next sprint.\n\n`;
  } else {
    markdown += `Fix opportunistically when working in related code.\n\n`;
  }

  return markdown;
}

function compareWithPreviousRun(
  current: EvaluationResult,
  monorepoRoot: string
): string | null {
  try {
    // Compare against established baseline, not just previous run
    const baselinesDir = resolve(
      monorepoRoot,
      "thoughts/shared/evaluations/baselines"
    );
    const baselineFiles = readdirSync(baselinesDir)
      .filter((f) => f.endsWith(".json"))
      .sort()
      .reverse();

    if (baselineFiles.length === 0) {
      return "*No baseline found — run pipeline to establish baseline.*";
    }

    // Get most recent baseline
    const baselineFile = baselineFiles[0];
    if (!baselineFile) {
      return "*No baseline found — run pipeline to establish baseline.*";
    }
    const baselinePath = resolve(baselinesDir, baselineFile);
    const baseline: EvaluationResult = JSON.parse(
      readFileSync(baselinePath, "utf-8")
    );

    // Also get previous run for additional context
    const resultsDir = resolve(
      monorepoRoot,
      "thoughts/shared/evaluations/results"
    );
    const resultFiles = readdirSync(resultsDir)
      .filter((f) => f.endsWith(".json"))
      .sort()
      .reverse();

    let previous: EvaluationResult | null = null;
    if (resultFiles.length >= 2) {
      const previousFile = resultFiles[1];
      if (previousFile) {
        const previousPath = resolve(resultsDir, previousFile);
        previous = JSON.parse(readFileSync(previousPath, "utf-8"));
      }
    }

    // Compare findings by ID against baseline
    const currentIds = new Set(current.findings.map((f) => f.id));
    const baselineIds = new Set(baseline.findings.map((f) => f.id));

    const newFindings = current.findings.filter(
      (f) => !baselineIds.has(f.id)
    );
    const resolvedFindings = baseline.findings.filter(
      (f) => !currentIds.has(f.id)
    );

    let diff = `### Compared to Baseline (\`${baselineFile}\`)\n\n`;

    if (newFindings.length === 0 && resolvedFindings.length === 0) {
      diff += "*No changes since baseline.*\n\n";
    } else {
      if (newFindings.length > 0) {
        diff += `**New Findings Since Baseline** (${newFindings.length}):\n`;
        for (const f of newFindings.slice(0, 5)) {
          diff += `- ${f.id}: ${f.title}\n`;
        }
        if (newFindings.length > 5) {
          diff += `- ... and ${newFindings.length - 5} more\n`;
        }
        diff += `\n`;
      }

      if (resolvedFindings.length > 0) {
        diff += `**Resolved Since Baseline** (${resolvedFindings.length}):\n`;
        for (const f of resolvedFindings.slice(0, 5)) {
          diff += `- ${f.id}: ${f.title}\n`;
        }
        if (resolvedFindings.length > 5) {
          diff += `- ... and ${resolvedFindings.length - 5} more\n`;
        }
        diff += `\n`;
      }
    }

    // Baseline comparison summary
    diff += `**Baseline Comparison**:\n`;
    diff += `- Total findings: ${baseline.summary.total_findings} → ${current.summary.total_findings} (${current.summary.total_findings - baseline.summary.total_findings > 0 ? "+" : ""}${current.summary.total_findings - baseline.summary.total_findings})\n`;
    diff += `- Tier 1: ${baseline.summary.tier1_count} → ${current.summary.tier1_count} (${current.summary.tier1_count - baseline.summary.tier1_count > 0 ? "+" : ""}${current.summary.tier1_count - baseline.summary.tier1_count})\n`;
    diff += `- Signal ratio: ${Math.round(baseline.summary.signal_ratio * 100)}% → ${Math.round(current.summary.signal_ratio * 100)}%\n`;

    // Also show previous run comparison if available
    if (previous) {
      diff += `\n### Compared to Previous Run\n\n`;
      const prevNewFindings = current.findings.filter(
        (f) => !new Set(previous.findings.map((pf) => pf.id)).has(f.id)
      );
      const prevResolvedFindings = previous.findings.filter(
        (f) => !currentIds.has(f.id)
      );

      if (prevNewFindings.length === 0 && prevResolvedFindings.length === 0) {
        diff += "*No changes since previous run.*\n";
      } else {
        if (prevNewFindings.length > 0) {
          diff += `- ${prevNewFindings.length} new finding(s)\n`;
        }
        if (prevResolvedFindings.length > 0) {
          diff += `- ${prevResolvedFindings.length} resolved finding(s)\n`;
        }
      }
    }

    return diff;
  } catch {
    return null;
  }
}
