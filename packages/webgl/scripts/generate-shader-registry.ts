#!/usr/bin/env node
import * as fs from "fs";
import * as path from "path";
import * as glob from "glob";

// Configuration
const SOURCE_DIR = path.resolve(__dirname, "../src");
const IMPL_DIR = path.join(SOURCE_DIR, "shaders/impl");
const OUTPUT_FILE = path.join(
  SOURCE_DIR,
  "generated/shader-registry.generated.ts",
);
const ENUM_FILE = path.join(SOURCE_DIR, "generated/shader-enum.generated.ts");

// Ensure the output directory exists
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
  console.log(`Created output directory: ${outputDir}`);
}

interface ShaderInfo {
  name: string;
  importPath: string;
  exportName: string;
}

/**
 * Discover shader definitions in the impl directory
 */
function discoverShaders(): ShaderInfo[] {
  console.log(`Scanning for shaders in: ${IMPL_DIR}`);

  if (!fs.existsSync(IMPL_DIR)) {
    console.error(`ERROR: Implementation directory not found: ${IMPL_DIR}`);
    return [];
  }

  try {
    // Only look for implementation files in the impl directory
    const implFiles = glob.sync("**/*.ts", {
      cwd: IMPL_DIR,
      absolute: true,
      ignore: "**/*.test.ts", // Ignore test files
    });

    console.log(`Found ${implFiles.length} potential shader files.`);

    if (implFiles.length === 0) {
      console.warn(`WARNING: No shader files found in ${IMPL_DIR}.`);
      return [];
    }

    const results: ShaderInfo[] = [];
    const processingErrors: string[] = [];

    for (const file of implFiles) {
      try {
        // Read the file content
        const content = fs.readFileSync(file, "utf-8");

        // Extract the shader name from SHADER_NAME constant
        const nameConstMatch = /const\s+SHADER_NAME\s*=\s*["'](\w+)["']/.exec(
          content,
        );

        // Look for shader definition pattern
        const shaderDefMatch =
          /export\s+const\s+(\w+(?:ShaderDefinition))\s*=/.exec(content);

        if (shaderDefMatch?.[1]) {
          const exportName = shaderDefMatch[1];
          let name: string;

          if (nameConstMatch?.[1]) {
            name = nameConstMatch[1];
          } else {
            // Extract from definition name
            const baseName = exportName.replace(/ShaderDefinition$/, "");
            // Convert camelCase to PascalCase if needed
            name = baseName.charAt(0).toUpperCase() + baseName.slice(1);

            console.warn(
              `WARNING: No SHADER_NAME constant found in ${path.basename(file)}. Derived name: "${name}"`,
            );
          }

          // Create relative import path
          const relativePath = path
            .relative(outputDir, file)
            .replace(/\\/g, "/") // Normalize Windows paths
            .replace(/\.tsx?$/, ""); // Remove extension

          results.push({
            name,
            exportName,
            importPath: relativePath,
          });

          console.log(
            `Discovered shader: ${name} (${exportName}) from ${path.basename(file)}`,
          );
        } else {
          console.warn(
            `WARNING: No shader definition export found in ${path.basename(file)}`,
          );
        }
      } catch (error) {
        const errorMessage = `Error processing file ${file}: ${error instanceof Error ? error.message : String(error)}`;
        processingErrors.push(errorMessage);
        console.error(errorMessage);
      }
    }

    if (processingErrors.length > 0) {
      console.error(
        `\nERROR: ${processingErrors.length} errors occurred while processing shader files.`,
      );
    }

    if (results.length === 0) {
      console.error(
        `ERROR: No valid shader definitions found in ${implFiles.length} files.`,
      );
    }

    return results;
  } catch (error) {
    console.error(
      `ERROR: Failed to scan for shader files: ${error instanceof Error ? error.message : String(error)}`,
    );
    return [];
  }
}

/**
 * Generate the enum file
 */
function generateEnumFile(shaders: ShaderInfo[]): boolean {
  if (shaders.length === 0) {
    console.error("ERROR: Cannot generate enum file with no shaders.");
    return false;
  }

  console.log(`Generating enum file with ${shaders.length} shader types...`);

  try {
    const enumContent = `/**
 * GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by generate-shader-registry.js
 * Generated on: ${new Date().toISOString()}
 */

import { z } from "zod";

export const $Shaders = z.enum([
${shaders.map((s) => `  "${s.name}",`).join("\n")}
]);

export type Shaders = z.infer<typeof $Shaders>;
`;

    fs.writeFileSync(ENUM_FILE, enumContent.trim());
    console.log(`Generated enum file: ${ENUM_FILE}`);
    return true;
  } catch (error) {
    console.error(
      `ERROR: Failed to generate enum file: ${error instanceof Error ? error.message : String(error)}`,
    );
    return false;
  }
}

/**
 * Generate the registry file
 */
function generateRegistryFile(shaders: ShaderInfo[]): boolean {
  if (shaders.length === 0) {
    console.error("ERROR: Cannot generate registry file with no shaders.");
    return false;
  }

  console.log(
    `Generating registry file with ${shaders.length} shader registrations...`,
  );

  try {
    const imports = shaders
      .map(
        (shader) =>
          `import { ${shader.exportName} } from "${shader.importPath}";`,
      )
      .join("\n");

    const registrations = shaders
      .map((shader) => `  registerShader(${shader.exportName});`)
      .join("\n");

    const content = `
/**
 * GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by generate-shader-registry.ts
 * Generated on: ${new Date().toISOString()}
 */

import { registerShader } from "../registry";
${imports}

/**
 * Register all discovered shaders
 * This function is automatically generated during build
 */
export function registerGeneratedShaders(): void {
${registrations}
}

// Register shaders when this module is imported
registerGeneratedShaders();
`;

    fs.writeFileSync(OUTPUT_FILE, content.trim());
    console.log(`Generated registry file: ${OUTPUT_FILE}`);
    return true;
  } catch (error) {
    console.error(
      `ERROR: Failed to generate registry file: ${error instanceof Error ? error.message : String(error)}`,
    );
    return false;
  }
}

// Main execution
try {
  console.log("======== Shader Registry Generator ========");
  console.log("Discovering shaders...");
  const shaders = discoverShaders();

  if (shaders.length === 0) {
    console.error("ERROR: No shader definitions found. Generation aborted.");
    process.exit(1);
  } else {
    console.log(`\nFound ${shaders.length} shader definitions.`);

    // Generate files
    const enumSuccess = generateEnumFile(shaders);
    const registrySuccess = generateRegistryFile(shaders);

    if (enumSuccess && registrySuccess) {
      console.log("\nShader registry generation complete!");
      process.exit(0);
    } else {
      console.error("\nERROR: Shader registry generation failed.");
      process.exit(1);
    }
  }
} catch (error) {
  console.error(
    `\nFATAL ERROR: ${error instanceof Error ? error.message : String(error)}`,
  );
  process.exit(1);
}
