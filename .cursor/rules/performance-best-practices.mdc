---
description: Performance optimization techniques for the React TD repository
globs: "**/*.ts,**/*.tsx"
alwaysApply: true
---

# React TD Performance Best Practices

## React Optimization
- Use `React.memo()` for components with static or rarely changing props
- Avoid inline function definitions in render to prevent unnecessary re-renders
- Use the callback pattern with proper dependencies:
  ```typescript
  const handleClick = useCallback(() => {
    // Implementation
  }, [dependencies]);
  ```
- Properly declare dependencies in hooks
- Avoid complex calculations in render functions

## State Management Optimization
- Use selectors to access only the state that's needed:
  ```typescript
  // Only get what you need
  const { targets } = useTextureRenderStore((state) => state);
  ```
- Batch state updates when possible
- Avoid storing derived state - compute it on demand
- Use appropriate memoization for derived values:
  ```typescript
  const derivedValue = useMemo(() => {
    return expensiveComputation(value);
  }, [value]);
  ```
- Minimize state updates during animations

## Rendering Optimization
- Cache computed values with `useMemo`
- Use virtualization for long lists (react-window or react-virtualized)
- Implement proper shouldComponentUpdate or use React.memo
- Avoid deep component trees
- Consider code-splitting for large components

## Memory Management
- Use `useRef` for values that shouldn't trigger re-renders
- Clean up resources in useEffect return functions:
  ```typescript
  useEffect(() => {
    // Setup
    return () => {
      // Cleanup
    };
  }, [dependencies]);
  ```
- Avoid memory leaks by unsubscribing from events and intervals
- Clear references to large objects when no longer needed
- Be careful with closure captures in event handlers

## Three.js and WebGL Performance
- Cache and reuse Three.js objects and materials
- Use instancing for repeated geometries
- Implement proper LOD (Level of Detail) for complex scenes
- Optimize shader complexity
- Use appropriate texture sizes and formats
- Implement object pooling for frequently created/destroyed objects
- Use workers for heavy computations

## Async Operations
- Implement proper loading states
- Use debounce for frequent updates:
  ```typescript
  const debouncedHandler = useDebounce((value) => {
    // Handler implementation
  }, DEBOUNCE_DELAY);
  ```
- Cancel unnecessary requests when component unmounts
- Use suspense and concurrent mode where appropriate
- Implement proper error handling

## Measurement and Monitoring
- Use React Profiler to identify performance bottlenecks
- Monitor memory usage and frame rates
- Implement performance metrics collection
- Test performance on different devices
- Follow established performance patterns from the codebase 