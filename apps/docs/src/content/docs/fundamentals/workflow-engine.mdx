---
title: Workflow Engine
description: Build complex multi-agent workflows
---

# Workflow Engine

The Lightfast Workflow Engine enables orchestration of complex multi-agent systems with sophisticated control flow, state management, and error handling.

## Overview

Workflows allow you to:
- Coordinate multiple agents
- Implement complex business logic
- Handle conditional execution
- Manage distributed state
- Ensure reliability at scale

## Basic Workflow

```typescript
import { Workflow } from '@lightfast/sdk';

const workflow = new Workflow({
  name: 'document-processor',
  description: 'Extract and analyze document content',
  steps: [
    {
      id: 'extract',
      agent: 'ocr-agent',
      input: '${input.document}'
    },
    {
      id: 'analyze',
      agent: 'nlp-agent',
      input: '${steps.extract.output}'
    }
  ]
});
```

## Control Flow

### Sequential Execution

Execute steps in order:

```typescript
const sequential = {
  steps: [
    { id: 'step1', action: 'process' },
    { id: 'step2', action: 'validate', dependsOn: ['step1'] },
    { id: 'step3', action: 'save', dependsOn: ['step2'] }
  ]
};
```

### Parallel Execution

Run multiple steps simultaneously:

```typescript
const parallel = {
  steps: [
    { id: 'fetch-data', action: 'fetch' },
    { id: 'fetch-config', action: 'fetch' },
    { 
      id: 'process',
      action: 'combine',
      dependsOn: ['fetch-data', 'fetch-config']
    }
  ]
};
```

### Conditional Branching

Make decisions based on runtime conditions:

```typescript
const conditional = {
  steps: [
    {
      id: 'check-type',
      action: 'evaluate',
      output: { type: 'document' | 'image' }
    },
    {
      id: 'process-document',
      action: 'extract-text',
      condition: '${steps.check-type.output.type === "document"}'
    },
    {
      id: 'process-image',
      action: 'extract-vision',
      condition: '${steps.check-type.output.type === "image"}'
    }
  ]
};
```

## State Management

### Workflow Context

Share data across steps:

```typescript
interface WorkflowContext {
  input: Record<string, any>;
  steps: Record<string, StepResult>;
  globals: Record<string, any>;
  secrets: Record<string, string>;
}
```

### State Persistence

Workflows automatically persist state for reliability:

```typescript
const workflow = new Workflow({
  persistence: {
    enabled: true,
    checkpointInterval: 5, // steps
    retentionDays: 30
  }
});
```

## Error Handling

### Retry Strategies

Configure retry behavior per step:

```typescript
{
  id: 'api-call',
  action: 'fetch',
  retry: {
    attempts: 3,
    backoff: 'exponential',
    initialDelay: 1000,
    maxDelay: 30000,
    retryOn: ['timeout', 'rate_limit']
  }
}
```

### Error Boundaries

Catch and handle errors gracefully:

```typescript
{
  steps: [
    {
      id: 'risky-operation',
      action: 'process',
      onError: {
        action: 'fallback',
        input: { useCache: true }
      }
    }
  ]
}
```

## Advanced Features

### Loops and Iteration

Process collections with map/reduce patterns:

```typescript
const mapReduce = {
  steps: [
    {
      id: 'map',
      action: 'foreach',
      items: '${input.documents}',
      do: {
        action: 'process-document',
        input: '${item}'
      }
    },
    {
      id: 'reduce',
      action: 'aggregate',
      input: '${steps.map.outputs}'
    }
  ]
};
```

### Dynamic Workflows

Generate workflow steps at runtime:

```typescript
const dynamic = {
  steps: [
    {
      id: 'plan',
      action: 'generate-plan',
      output: { steps: [...] }
    },
    {
      id: 'execute',
      action: 'dynamic',
      workflow: '${steps.plan.output.steps}'
    }
  ]
};
```

### Sub-workflows

Compose workflows from smaller units:

```typescript
const parent = {
  steps: [
    {
      id: 'preprocess',
      workflow: 'data-validation-workflow'
    },
    {
      id: 'main',
      workflow: 'processing-workflow',
      input: '${steps.preprocess.output}'
    }
  ]
};
```

## Human-in-the-Loop

### Approval Gates

Require human approval before proceeding:

```typescript
{
  id: 'approval',
  action: 'wait-for-approval',
  config: {
    approvers: ['user@example.com'],
    timeout: '24h',
    message: 'Please review the analysis results'
  }
}
```

### Manual Tasks

Include human tasks in workflows:

```typescript
{
  id: 'manual-review',
  action: 'human-task',
  config: {
    assignee: '${input.reviewer}',
    instructions: 'Review and annotate the document',
    schema: {
      approved: 'boolean',
      comments: 'string'
    }
  }
}
```

## Monitoring

### Workflow Metrics

Track performance and success rates:

```typescript
const metrics = await workflow.getMetrics();
// {
//   executions: 1523,
//   successRate: 0.98,
//   avgDuration: 45.3,
//   p95Duration: 89.2
// }
```

### Real-time Status

Monitor running workflows:

```typescript
const status = await workflow.getStatus(executionId);
// {
//   state: 'running',
//   currentStep: 'analyze',
//   progress: 0.65,
//   startTime: '2024-01-10T10:00:00Z'
// }
```

## Best Practices

### 1. Idempotency
Design steps to be safely retryable.

### 2. Timeout Configuration
Set appropriate timeouts for each step.

### 3. State Minimization
Keep workflow state lean for performance.

### 4. Error Isolation
Use error boundaries to prevent cascade failures.

### 5. Monitoring
Implement comprehensive logging and metrics.

## Examples

### Document Processing Pipeline

```typescript
const documentPipeline = new Workflow({
  name: 'document-pipeline',
  steps: [
    {
      id: 'validate',
      agent: 'validator',
      input: '${input.document}'
    },
    {
      id: 'extract',
      agent: 'extractor',
      input: '${steps.validate.output}',
      retry: { attempts: 3 }
    },
    {
      id: 'enrich',
      agent: 'enricher',
      input: '${steps.extract.output}'
    },
    {
      id: 'quality-check',
      action: 'wait-for-approval',
      condition: '${steps.enrich.output.confidence < 0.8}'
    },
    {
      id: 'save',
      agent: 'storage',
      input: '${steps.enrich.output}'
    }
  ]
});
```

The Workflow Engine provides the foundation for building sophisticated agent systems that can handle real-world complexity.