---
title: State Management
description: Managing state in agent applications
---

# State Management

Effective state management is crucial for building reliable agent applications. Lightfast provides comprehensive state management capabilities at multiple levels.

## State Types

### Conversation State

Maintains context throughout an agent interaction:

```typescript
interface ConversationState {
  id: string;
  messages: Message[];
  context: Record<string, any>;
  metadata: {
    startTime: Date;
    lastActivity: Date;
    tokenCount: number;
  };
}
```

### Execution State

Tracks the progress of agent tasks:

```typescript
interface ExecutionState {
  taskId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress: number;
  checkpoints: Checkpoint[];
  results: any;
}
```

### Application State

Global state shared across agents:

```typescript
interface ApplicationState {
  users: Map<string, UserData>;
  sessions: Map<string, SessionData>;
  cache: Map<string, CachedData>;
}
```

## State Persistence

### Storage Backends

Configure where state is stored:

```typescript
const agent = new Agent({
  state: {
    backend: 'redis', // 'memory' | 'redis' | 'dynamodb' | 'postgres'
    config: {
      url: 'redis://localhost:6379',
      ttl: 3600 // seconds
    }
  }
});
```

### State Serialization

Automatic serialization and deserialization:

```typescript
class StateManager {
  async save(key: string, state: any): Promise<void> {
    const serialized = JSON.stringify(state);
    await this.backend.set(key, serialized);
  }

  async load<T>(key: string): Promise<T | null> {
    const data = await this.backend.get(key);
    return data ? JSON.parse(data) : null;
  }
}
```

## Context Management

### Context Window

Manage token limits effectively:

```typescript
class ContextManager {
  private maxTokens = 8000;
  private messages: Message[] = [];

  addMessage(message: Message) {
    this.messages.push(message);
    this.truncateIfNeeded();
  }

  private truncateIfNeeded() {
    while (this.getTokenCount() > this.maxTokens) {
      this.messages.shift(); // Remove oldest
    }
  }
}
```

### Context Compression

Reduce token usage while preserving information:

```typescript
const compressed = await compress({
  messages: conversation,
  strategy: 'summary', // 'summary' | 'key-points' | 'embeddings'
  targetTokens: 2000
});
```

## Memory Systems

### Short-term Memory

In-session information storage:

```typescript
class ShortTermMemory {
  private data = new Map();
  private maxAge = 3600000; // 1 hour

  set(key: string, value: any) {
    this.data.set(key, {
      value,
      timestamp: Date.now()
    });
  }

  get(key: string) {
    const entry = this.data.get(key);
    if (!entry) return null;
    
    if (Date.now() - entry.timestamp > this.maxAge) {
      this.data.delete(key);
      return null;
    }
    
    return entry.value;
  }
}
```

### Long-term Memory

Persistent storage with vector search:

```typescript
class LongTermMemory {
  async store(content: string, metadata: any) {
    const embedding = await this.embed(content);
    await this.vectorDB.insert({
      embedding,
      content,
      metadata,
      timestamp: new Date()
    });
  }

  async recall(query: string, limit = 5) {
    const queryEmbedding = await this.embed(query);
    return this.vectorDB.search(queryEmbedding, limit);
  }
}
```

## State Synchronization

### Distributed State

Synchronize state across multiple instances:

```typescript
class DistributedState {
  private pubsub: PubSub;
  private localState: Map<string, any>;

  async update(key: string, value: any) {
    this.localState.set(key, value);
    await this.pubsub.publish('state-update', { key, value });
  }

  constructor() {
    this.pubsub.subscribe('state-update', (data) => {
      this.localState.set(data.key, data.value);
    });
  }
}
```

### Conflict Resolution

Handle concurrent state updates:

```typescript
interface StateUpdate {
  version: number;
  timestamp: Date;
  data: any;
}

class ConflictResolver {
  resolve(updates: StateUpdate[]): StateUpdate {
    // Last-write-wins strategy
    return updates.sort((a, b) => 
      b.timestamp.getTime() - a.timestamp.getTime()
    )[0];
  }
}
```

## State Patterns

### Event Sourcing

Store state changes as events:

```typescript
class EventStore {
  private events: Event[] = [];

  append(event: Event) {
    this.events.push({
      ...event,
      timestamp: new Date(),
      id: generateId()
    });
  }

  replay(): State {
    return this.events.reduce((state, event) => 
      this.applyEvent(state, event), 
      this.initialState()
    );
  }
}
```

### CQRS Pattern

Separate read and write models:

```typescript
class StateStore {
  // Write side
  async command(cmd: Command): Promise<void> {
    const event = this.processCommand(cmd);
    await this.eventStore.append(event);
    await this.updateReadModel(event);
  }

  // Read side
  async query(query: Query): Promise<any> {
    return this.readModel.execute(query);
  }
}
```

## State Optimization

### Lazy Loading

Load state only when needed:

```typescript
class LazyState {
  private cache = new Map();

  async get(key: string) {
    if (!this.cache.has(key)) {
      const value = await this.loadFromStorage(key);
      this.cache.set(key, value);
    }
    return this.cache.get(key);
  }
}
```

### State Pruning

Remove unnecessary state:

```typescript
class StatePruner {
  async prune() {
    const cutoff = Date.now() - this.retentionPeriod;
    
    await this.storage.deleteWhere({
      lastAccessed: { $lt: cutoff }
    });
  }
}
```

## Debugging State

### State Inspection

Tools for examining state:

```typescript
const inspector = new StateInspector();

// Snapshot current state
const snapshot = await inspector.capture();

// Compare states
const diff = inspector.diff(snapshot1, snapshot2);

// Visualize state
await inspector.visualize(snapshot, 'state-diagram.png');
```

### Time Travel Debugging

Navigate through state history:

```typescript
class StateDebugger {
  async rewindTo(timestamp: Date) {
    const events = await this.getEventsUntil(timestamp);
    return this.replay(events);
  }

  async stepForward() {
    const nextEvent = await this.getNextEvent();
    return this.applyEvent(this.currentState, nextEvent);
  }
}
```

## Best Practices

1. **Minimize State Size**: Keep only essential data
2. **Use Appropriate Storage**: Match backend to access patterns
3. **Implement Versioning**: Track state schema changes
4. **Handle Failures**: Design for network partitions
5. **Monitor State Growth**: Set up alerts for abnormal growth

State management is fundamental to building robust agent applications with Lightfast.