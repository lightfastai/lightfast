---
title: Search Strategies
description: Learn how to optimize your search queries for better results
---

# Search Strategies

Get the most out of Lightfast search by using effective query strategies. This guide shows you how to craft queries that return the most relevant results.

## Natural Language Queries

Lightfast understands natural language. Write queries as if you're asking a colleague.

### ✅ Good Queries

```typescript
// Specific and contextual
await lf.search({ query: 'how does our OAuth authentication flow work?' })
await lf.search({ query: 'recent changes to payment processing' })
await lf.search({ query: 'who has worked on the mobile app login?' })
```

### ❌ Less Effective Queries

```typescript
// Too vague or keyword-only
await lf.search({ query: 'auth' })
await lf.search({ query: 'payment' })
await lf.search({ query: 'mobile' })
```

## Query Types

### Factual Questions

Ask specific questions about your codebase:

```typescript
const result = await lf.search({
  query: 'What is our API rate limit for authenticated requests?'
})
```

### Exploratory Queries

Discover related concepts:

```typescript
const result = await lf.search({
  query: 'different approaches to caching in our services'
})
```

### "Who" Questions

Find people with expertise:

```typescript
const result = await lf.search({
  query: 'who has worked on authentication and security?'
})

// Extract owners
const experts = [...new Set(result.data.map(r => r.owner))]
```

### "Why" Questions

Trace decision context:

```typescript
const result = await lf.search({
  query: 'why did we choose PostgreSQL over MongoDB?',
  filters: {
    type: ['discussion', 'rfc', 'doc']
  }
})
```

### "When" Questions

Find temporal information:

```typescript
const result = await lf.search({
  query: 'recent changes to deployment process',
  filters: {
    createdAfter: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()
  }
})
```

## Using Filters

Combine semantic search with filters for precision.

### Filter by Type

```typescript
// Code-related only
const code = await lf.search({
  query: 'rate limiting implementation',
  filters: {
    type: ['pull_request', 'code', 'issue']
  }
})

// Documentation only
const docs = await lf.search({
  query: 'API authentication guide',
  filters: {
    type: ['doc', 'guide', 'tutorial']
  }
})
```

### Filter by Date

```typescript
// Last 3 months
const recent = await lf.search({
  query: 'authentication changes',
  filters: {
    createdAfter: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString()
  }
})

// Specific time range
const q4 = await lf.search({
  query: 'product updates',
  filters: {
    createdAfter: '2024-10-01',
    createdBefore: '2024-12-31'
  }
})
```

### Filter by Source

```typescript
// GitHub only
const github = await lf.search({
  query: 'security vulnerabilities',
  filters: {
    source: 'github',
    type: ['issue', 'pull_request']
  }
})

// Notion docs only
const notion = await lf.search({
  query: 'team processes',
  filters: {
    source: 'notion'
  }
})
```

### Custom Metadata Filters

```typescript
const critical = await lf.search({
  query: 'bugs in production',
  filters: {
    state: 'open',
    labels: ['critical', 'production'],
    repository: 'org/api-service'
  }
})
```

## Pagination

Handle large result sets efficiently:

```typescript
async function searchAll(query: string) {
  const allResults = []
  let offset = 0
  const limit = 50

  while (true) {
    const page = await lf.search({
      query,
      limit,
      offset
    })

    allResults.push(...page.data)

    if (offset + limit >= page.meta.total) break
    offset += limit
  }

  return allResults
}
```

## Understanding Results

### Score Interpretation

- **0.90-1.00**: Highly relevant, exact match
- **0.75-0.89**: Very relevant, strong semantic match
- **0.60-0.74**: Relevant, good match
- **0.40-0.59**: Somewhat relevant
- **< 0.40**: Weakly relevant

### Using Rationale

Enable `includeRationale` to understand ranking:

```typescript
const results = await lf.search({
  query: 'authentication security best practices',
  includeRationale: true
})

results.data.forEach(result => {
  console.log(`Score: ${result.score}`)
  console.log(`Why: ${result.rationale}`)
  console.log('---')
})
```

Example output:
```
Score: 0.92
Why: High semantic similarity. Recent merge. Owned by security team.
     Contains "authentication" and "security" labels. Referenced in 3 related discussions.
---
```

## Advanced Patterns

### Multi-Stage Search

Refine results progressively:

```typescript
// Stage 1: Broad search
const broad = await lf.search({
  query: 'payment processing',
  limit: 100
})

// Stage 2: Filter high-scoring results
const relevant = broad.data.filter(r => r.score > 0.75)

// Stage 3: Get similar content
const similar = await Promise.all(
  relevant.slice(0, 5).map(r =>
    lf.similar({ id: r.id, limit: 3 })
  )
)
```

### Combine Search + Answer

Use search for discovery, answer for synthesis:

```typescript
// Find relevant content
const results = await lf.search({
  query: 'deployment process',
  limit: 10
})

// Get synthesized answer from top results
const answer = await lf.answer({
  query: 'What are the steps in our deployment process?',
  filters: {
    id: results.data.slice(0, 5).map(r => r.id)
  }
})
```

### Federated Search

Search across multiple filters, combine results:

```typescript
async function federatedSearch(query: string) {
  const [code, docs, discussions] = await Promise.all([
    lf.search({ query, filters: { type: ['pull_request', 'code'] } }),
    lf.search({ query, filters: { type: ['doc', 'guide'] } }),
    lf.search({ query, filters: { type: ['discussion', 'issue'] } })
  ])

  return {
    code: code.data,
    docs: docs.data,
    discussions: discussions.data
  }
}
```

## Common Patterns

### Find Experts

```typescript
async function findExperts(topic: string) {
  const results = await lf.search({
    query: topic,
    limit: 50
  })

  // Count contributions per owner
  const contributions = new Map<string, number>()
  results.data.forEach(r => {
    if (r.owner) {
      contributions.set(r.owner, (contributions.get(r.owner) || 0) + 1)
    }
  })

  // Sort by contributions
  return Array.from(contributions.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([owner, count]) => ({ owner, count }))
}
```

### Detect Duplicates

```typescript
async function findDuplicates(title: string) {
  const similar = await lf.search({
    query: title,
    filters: {
      type: ['issue'],
      state: 'open'
    },
    limit: 10
  })

  return similar.data.filter(r => r.score > 0.90)
}
```

### Track Changes

```typescript
async function trackChanges(topic: string, days = 7) {
  const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000)

  return await lf.search({
    query: topic,
    filters: {
      updatedAfter: cutoff.toISOString()
    }
  })
}
```

## Performance Tips

### Use Appropriate Limits

Request only what you need:

```typescript
// ✅ Good: Small limit for UI
const results = await lf.search({ query, limit: 10 })

// ❌ Wasteful: Large limit when showing 10
const results = await lf.search({ query, limit: 100 })
```

### Apply Filters Early

Filter on server, not client:

```typescript
// ✅ Good: Server-side filter
const results = await lf.search({
  query,
  filters: { type: ['pull_request'] }
})

// ❌ Bad: Client-side filter
const all = await lf.search({ query, limit: 100 })
const filtered = all.data.filter(r => r.type === 'pull_request')
```

### Cache Common Queries

Cache frequently searched queries:

```typescript
const cache = new Map<string, any>()
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

async function cachedSearch(query: string) {
  const key = `search:${query}`

  if (cache.has(key)) {
    return cache.get(key)
  }

  const result = await lf.search({ query })
  cache.set(key, result)

  setTimeout(() => cache.delete(key), CACHE_TTL)

  return result
}
```

## Troubleshooting

### No Results

If search returns no results:

1. **Broaden the query**: Use more general terms
2. **Remove filters**: Check if filters are too restrictive
3. **Check spelling**: Ensure query terms are spelled correctly
4. **Try synonyms**: Use alternative phrasing

```typescript
// Too specific
await lf.search({ query: 'OAuth 2.0 PKCE implementation in auth service' })

// Better
await lf.search({ query: 'OAuth authentication' })
```

### Irrelevant Results

If results aren't relevant:

1. **Be more specific**: Add context to query
2. **Use filters**: Narrow by type, source, date
3. **Check highlights**: See what text matched

```typescript
// Too broad
await lf.search({ query: 'performance' })

// Better
await lf.search({
  query: 'API performance optimization strategies',
  filters: {
    type: ['pull_request', 'doc'],
    createdAfter: '2024-01-01'
  }
})
```

## Next Steps

- **[Working with Citations](/docs/guides/citations)** - Display and verify sources
- **[Discovery Patterns](/docs/guides/discovery-patterns)** - Explore related content
- **[Answer Quality](/docs/guides/answer-quality)** - Get better synthesized answers
- **[API Reference: Search](/api/search)** - Complete search endpoint docs
