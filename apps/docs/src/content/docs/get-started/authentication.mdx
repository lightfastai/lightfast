---
title: Authentication
description: Learn how to authenticate with the Lightfast API
---

# Authentication

All Lightfast API requests require authentication using API keys. This guide covers everything you need to know about securing your requests.

## API Keys

Lightfast uses **Bearer token authentication**. Include your API key in the `Authorization` header:

```bash
Authorization: Bearer lf_sk_live_abc123...
```

### Key Types

Lightfast provides three types of API keys with different permission levels:

| Type | Prefix | Permissions | Use Case |
|------|--------|-------------|----------|
| **Secret Key** | `lf_sk_` | Full access (read, write, admin) | Server-side applications |
| **Publishable Key** | `lf_pk_` | Read-only search access | Client-side search UIs |
| **Restricted Key** | `lf_rk_` | Custom scopes | Scoped integrations |

### Getting Your API Key

1. Sign up at [lightfast.ai](https://lightfast.ai)
2. Navigate to **Settings → API Keys**
3. Click **Create New Key**
4. Select the key type and permissions
5. Copy the key immediately (you won't see it again)

## Using API Keys

### Server-Side (Secret Key)

Use secret keys for server-side applications with full access:


    ```typescript
    import { Lightfast } from '@lightfast/sdk'

    const lf = new Lightfast({
      apiKey: process.env.LIGHTFAST_API_KEY // lf_sk_live_...
    })

    // Full access to all endpoints
    await lf.search({ query: 'authentication' })
    await lf.contents({ ids: ['doc-1'] })
    await lf.similar({ id: 'doc-1' })
    await lf.answer({ query: 'how does auth work?' })
    ```
  

### Client-Side (Publishable Key)

Use publishable keys for client-side search interfaces (read-only):

```typescript
// Safe to use in browser code
const lf = new Lightfast({
  apiKey: 'lf_pk_live_...' // Publishable key
})

// Only search endpoints are accessible
const results = await lf.search({
  query: 'user query'
})
```

**Important**: Publishable keys can only call read-only endpoints (`/v1/search`, `/v1/contents`, `/v1/similar`, `/v1/answer`).

### Restricted Keys

Create custom keys with specific permissions:

```bash
# Example: Key that can only search specific collections
Permissions:
  - search:read on collection:github-org
  - search:read on collection:docs
```

This is useful for:
- **Partner integrations**: Limit access to specific data
- **Service accounts**: Scope to exact permissions needed
- **Testing environments**: Restrict to test data only

## Environment Variables

**Never hardcode API keys** in your source code. Use environment variables:

### Development

```bash
# .env.local
LIGHTFAST_API_KEY=lf_sk_test_abc123...
```

### Production

Set environment variables in your deployment platform:

<Tabs items={['Vercel', 'Railway', 'Render', 'AWS']}>
  <Tab value="Vercel">
    ```bash
    # Using Vercel CLI
    vercel env add LIGHTFAST_API_KEY

    # Or in Vercel Dashboard
    # Settings → Environment Variables → Add
    ```
  </Tab>

  <Tab value="Railway">
    ```bash
    # In Railway Dashboard
    # Variables → New Variable
    # LIGHTFAST_API_KEY = lf_sk_live_...
    ```
  </Tab>

  <Tab value="Render">
    ```bash
    # In Render Dashboard
    # Environment → Add Environment Variable
    # LIGHTFAST_API_KEY = lf_sk_live_...
    ```
  </Tab>

  <Tab value="AWS">
    ```bash
    # Using AWS Secrets Manager
    aws secretsmanager create-secret \
      --name lightfast-api-key \
      --secret-string "lf_sk_live_..."
    ```
  </Tab>
</Tabs>

## Security Best Practices

### Rotate Keys Regularly

Rotate API keys every 90 days:

```bash
# Create new key
# Update environment variables
# Delete old key
```

### Use Minimum Permissions

Always use the least privileged key for the task:
- ✅ Use publishable keys for client-side search
- ✅ Use restricted keys for specific integrations
- ❌ Don't use secret keys in client-side code

### Monitor Usage

Track API key usage in the dashboard:
- **Request counts**: Unusual spikes might indicate leaked keys
- **Error rates**: High error rates might indicate misconfiguration
- **Geographic patterns**: Unexpected locations might indicate compromise

### Revoke Compromised Keys

If a key is compromised:
1. **Immediately revoke** it in the dashboard
2. **Create a new key** with different credentials
3. **Update** all applications using the old key
4. **Review logs** for unauthorized access

## Rate Limiting

API keys are subject to rate limits based on your plan:

| Plan | Requests/min | Quota |
|------|--------------|-------|
| **Free** | 60 | 10K vectors |
| **Pro** | 600 | 100K vectors |
| **Team** | 3,000 | 500K vectors |
| **Enterprise** | Custom | Unlimited |

Rate limit information is included in response headers:

```http
X-RateLimit-Limit: 600
X-RateLimit-Remaining: 542
X-RateLimit-Reset: 1704110400
```

### Handling Rate Limits

When you hit a rate limit, you'll receive a `429` response:

```json
{
  "error": "rate_limit_exceeded",
  "message": "Rate limit exceeded. Retry after 42 seconds.",
  "retryAfter": 42,
  "requestId": "req_abc123"
}
```

**Best practice**: Implement exponential backoff:

```typescript
async function searchWithRetry(query: string, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await lf.search({ query })
    } catch (error) {
      if (error.code === 'rate_limit_exceeded' && i < maxRetries - 1) {
        const delay = Math.min(1000 * 2 ** i, 10000) // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay))
        continue
      }
      throw error
    }
  }
}
```

## CORS & Client-Side Usage

For client-side applications, configure allowed origins:

1. Navigate to **Settings → API Keys**
2. Select your publishable key
3. Add **Allowed Origins**:
   ```
   https://yourdomain.com
   https://app.yourdomain.com
   ```

Wildcards are supported for development:
```
http://localhost:*
```

## Webhook Signing

When using webhooks, Lightfast signs requests with your webhook secret:

```typescript
import { verifyWebhookSignature } from '@lightfast/sdk'

app.post('/webhook', (req, res) => {
  const signature = req.headers['x-lightfast-signature']
  const isValid = verifyWebhookSignature(
    req.body,
    signature,
    process.env.LIGHTFAST_WEBHOOK_SECRET
  )

  if (!isValid) {
    return res.status(401).json({ error: 'Invalid signature' })
  }

  // Process webhook
})
```

## Next Steps

- **[Quickstart](/docs/get-started/quickstart)** - Make your first authenticated request
- **[API Reference](/api/overview)** - Explore all endpoints
- **[Error Handling](/api/errors)** - Handle authentication errors gracefully
- **[Rate Limits](/docs/guides/rate-limits)** - Optimize your request patterns
