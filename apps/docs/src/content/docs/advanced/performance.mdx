---
title: Performance Optimization
description: Optimize agent performance for production
---

# Performance Optimization

Master techniques for optimizing agent performance in production environments.

## Token Optimization

### Context Management

```typescript
class ContextOptimizer {
  private maxTokens = 4000;
  
  optimizeContext(messages: Message[]): Message[] {
    let tokens = 0;
    const optimized: Message[] = [];
    
    // Keep most recent messages
    for (let i = messages.length - 1; i >= 0; i--) {
      const messageTokens = this.countTokens(messages[i]);
      
      if (tokens + messageTokens > this.maxTokens) {
        break;
      }
      
      optimized.unshift(messages[i]);
      tokens += messageTokens;
    }
    
    return optimized;
  }
}
```

### Response Streaming

```typescript
async function* streamResponse(input: string) {
  const stream = await agent.stream({ input });
  
  for await (const chunk of stream) {
    // Process chunk immediately
    yield processChunk(chunk);
  }
}
```

## Caching Strategies

### Semantic Caching

```typescript
class SemanticCache {
  private embeddings = new Map<string, number[]>();
  
  async get(query: string): Promise<any> {
    const queryEmbedding = await this.embed(query);
    
    for (const [key, embedding] of this.embeddings) {
      const similarity = this.cosineSimilarity(queryEmbedding, embedding);
      
      if (similarity > 0.95) {
        return this.cache.get(key);
      }
    }
    
    return null;
  }
}
```

## Batch Processing

```typescript
class BatchProcessor {
  async processBatch(items: any[], batchSize = 10) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map(item => this.processItem(item))
      );
      
      results.push(...batchResults);
    }
    
    return results;
  }
}
```

## Connection Pooling

```typescript
class ConnectionPool {
  private pool: Connection[] = [];
  private available: Connection[] = [];
  
  async getConnection(): Promise<Connection> {
    if (this.available.length > 0) {
      return this.available.pop()!;
    }
    
    if (this.pool.length < this.maxConnections) {
      const conn = await this.createConnection();
      this.pool.push(conn);
      return conn;
    }
    
    // Wait for available connection
    return this.waitForConnection();
  }
}
```

## Memory Management

```typescript
class MemoryManager {
  private heapLimit = 1024 * 1024 * 1024; // 1GB
  
  async monitorMemory() {
    const usage = process.memoryUsage();
    
    if (usage.heapUsed > this.heapLimit * 0.8) {
      await this.clearCache();
      global.gc?.(); // Force garbage collection if available
    }
  }
}
```

## Query Optimization

```typescript
class QueryOptimizer {
  optimizeDatabase() {
    // Add indexes
    db.createIndex('users', ['email', 'created_at']);
    
    // Use query hints
    db.query('SELECT /*+ INDEX(users email_idx) */ * FROM users');
    
    // Implement query caching
    db.enableQueryCache({ size: '100MB', ttl: 3600 });
  }
}
```

## Load Balancing

```typescript
class LoadBalancer {
  private instances: Instance[] = [];
  
  selectInstance(): Instance {
    // Least connections algorithm
    return this.instances.reduce((min, instance) => 
      instance.connections < min.connections ? instance : min
    );
  }
}
```

## Profiling

```typescript
class PerformanceProfiler {
  profile(fn: Function) {
    return async (...args: any[]) => {
      const start = performance.now();
      
      try {
        const result = await fn(...args);
        const duration = performance.now() - start;
        
        this.recordMetric({
          function: fn.name,
          duration,
          success: true
        });
        
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        
        this.recordMetric({
          function: fn.name,
          duration,
          success: false,
          error
        });
        
        throw error;
      }
    };
  }
}
```

Optimize for speed, scale, and efficiency!