---
title: Debugging Techniques
description: Debug and troubleshoot agent applications
---

# Debugging Techniques

Master debugging techniques for agent applications.

## Debug Mode

```typescript
const debugAgent = new Agent({
  name: 'debug-agent',
  debug: {
    enabled: true,
    verbosity: 'trace',
    logPrompts: true,
    logResponses: true,
    saveTranscripts: true
  }
});

// Access debug info
const info = debugAgent.getDebugInfo();
console.log('Execution trace:', info.trace);
```

## Logging

```typescript
class DebugLogger {
  log(level: string, message: string, context?: any) {
    const entry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      stack: new Error().stack
    };
    
    console.log(JSON.stringify(entry, null, 2));
    
    if (this.saveToFile) {
      fs.appendFileSync('debug.log', JSON.stringify(entry) + '\n');
    }
  }
}
```

## Tracing

```typescript
import { Tracer } from '@lightfast/tracing';

const tracer = new Tracer();

async function tracedExecution(input: string) {
  const span = tracer.startSpan('agent.execute');
  
  try {
    span.log({ event: 'input', data: input });
    
    const result = await agent.execute({ input });
    
    span.log({ event: 'output', data: result });
    
    return result;
  } catch (error) {
    span.setTag('error', true);
    span.log({ event: 'error', message: error.message });
    throw error;
  } finally {
    span.finish();
  }
}
```

## Interactive Debugging

```typescript
import repl from 'repl';

const debugRepl = repl.start({
  prompt: 'debug> '
});

debugRepl.context.agent = agent;
debugRepl.context.inspect = (obj: any) => {
  console.dir(obj, { depth: null, colors: true });
};
debugRepl.context.trace = () => {
  console.log(agent.getExecutionTrace());
};
```

## Error Analysis

```typescript
class ErrorAnalyzer {
  analyze(error: Error) {
    return {
      type: error.constructor.name,
      message: error.message,
      stack: this.parseStack(error.stack),
      context: this.getErrorContext(error),
      suggestions: this.getSuggestions(error)
    };
  }
  
  private getSuggestions(error: Error): string[] {
    if (error.message.includes('rate limit')) {
      return ['Implement exponential backoff', 'Reduce request frequency'];
    }
    
    if (error.message.includes('timeout')) {
      return ['Increase timeout', 'Optimize query', 'Check network'];
    }
    
    return ['Check logs', 'Review stack trace'];
  }
}
```

## State Inspection

```typescript
class StateInspector {
  inspectAgent(agent: Agent) {
    return {
      config: agent.getConfig(),
      state: agent.getState(),
      metrics: agent.getMetrics(),
      history: agent.getHistory()
    };
  }
  
  compareStates(before: any, after: any) {
    const diff = this.deepDiff(before, after);
    console.log('State changes:', diff);
    return diff;
  }
}
```

## Performance Profiling

```typescript
class Profiler {
  private timings = new Map();
  
  start(label: string) {
    this.timings.set(label, performance.now());
  }
  
  end(label: string) {
    const start = this.timings.get(label);
    if (!start) return;
    
    const duration = performance.now() - start;
    console.log(`${label}: ${duration.toFixed(2)}ms`);
    
    return duration;
  }
  
  async profile(fn: Function, label: string) {
    this.start(label);
    try {
      return await fn();
    } finally {
      this.end(label);
    }
  }
}
```

## Memory Debugging

```typescript
class MemoryDebugger {
  snapshot() {
    if (global.gc) {
      global.gc();
    }
    
    const usage = process.memoryUsage();
    
    return {
      rss: `${(usage.rss / 1024 / 1024).toFixed(2)} MB`,
      heapTotal: `${(usage.heapTotal / 1024 / 1024).toFixed(2)} MB`,
      heapUsed: `${(usage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
      external: `${(usage.external / 1024 / 1024).toFixed(2)} MB`
    };
  }
  
  detectLeaks() {
    const baseline = this.snapshot();
    
    return setInterval(() => {
      const current = this.snapshot();
      
      if (current.heapUsed > baseline.heapUsed * 2) {
        console.warn('Possible memory leak detected');
      }
    }, 60000);
  }
}
```

Debug smarter, ship faster!