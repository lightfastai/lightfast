---
title: Security Best Practices
description: Secure your agent deployments
---

# Security Best Practices

Comprehensive security guide for production agent deployments.

## Input Validation

```typescript
class InputValidator {
  validate(input: any): ValidationResult {
    // Check for injection attacks
    if (this.detectSQLInjection(input)) {
      throw new SecurityError('SQL injection detected');
    }
    
    // Check for prompt injection
    if (this.detectPromptInjection(input)) {
      throw new SecurityError('Prompt injection detected');
    }
    
    // Sanitize input
    return this.sanitize(input);
  }
  
  private detectPromptInjection(input: string): boolean {
    const patterns = [
      /ignore previous instructions/i,
      /disregard all prior commands/i,
      /system:/i
    ];
    
    return patterns.some(p => p.test(input));
  }
}
```

## Authentication & Authorization

```typescript
class SecurityMiddleware {
  async authenticate(request: Request) {
    const token = request.headers.authorization;
    
    if (!token) {
      throw new AuthError('No token provided');
    }
    
    const payload = await this.verifyToken(token);
    
    // Check permissions
    if (!this.hasPermission(payload.role, request.action)) {
      throw new AuthError('Insufficient permissions');
    }
    
    return payload;
  }
}
```

## Secrets Management

```typescript
class SecretManager {
  private vault = new HashiCorpVault();
  
  async getSecret(key: string): Promise<string> {
    // Never log secrets
    const secret = await this.vault.read(`secret/data/${key}`);
    
    // Rotate if needed
    if (this.shouldRotate(key)) {
      await this.rotateSecret(key);
    }
    
    return secret;
  }
}
```

## Rate Limiting

```typescript
class RateLimiter {
  async checkLimit(userId: string, action: string) {
    const key = `${userId}:${action}`;
    const count = await redis.incr(key);
    
    if (count === 1) {
      await redis.expire(key, 60); // 1 minute window
    }
    
    if (count > this.getLimit(action)) {
      throw new RateLimitError('Rate limit exceeded');
    }
  }
}
```

## Data Encryption

```typescript
class EncryptionService {
  encrypt(data: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(
      'aes-256-gcm',
      this.key,
      iv
    );
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return iv.toString('hex') + ':' + 
           authTag.toString('hex') + ':' + 
           encrypted;
  }
}
```

## Audit Logging

```typescript
class AuditLogger {
  async log(event: AuditEvent) {
    await this.store({
      timestamp: new Date(),
      userId: event.userId,
      action: event.action,
      resource: event.resource,
      ip: event.ip,
      userAgent: event.userAgent,
      result: event.result
    });
  }
}
```

## Sandboxing

```typescript
class Sandbox {
  async execute(code: string) {
    const vm = new VM({
      timeout: 5000,
      sandbox: {
        // Limited API
        console: console,
        Math: Math
      }
    });
    
    try {
      return vm.run(code);
    } catch (error) {
      throw new SecurityError('Sandbox execution failed');
    }
  }
}
```

## Network Security

```typescript
class NetworkSecurity {
  configureFirewall() {
    // Whitelist IPs
    this.firewall.allow(['10.0.0.0/8']);
    
    // Block malicious IPs
    this.firewall.block(this.blacklist);
    
    // Rate limit by IP
    this.firewall.rateLimit({
      windowMs: 60000,
      max: 100
    });
  }
}
```

Security first, always!